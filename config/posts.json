{
  "posts": [
    {
      "content": "### 题目\r\n给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\r\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\r\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\r\n<!-- more -->\r\n示例 1：\r\n输入：k = 2, prices = [2,4,1]\r\n输出：2\r\n解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\r\n\r\n示例 2：\r\n输入：k = 2, prices = [3,2,6,5,0,3]\r\n输出：7\r\n解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\r\n     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\r\n\r\n提示：\r\n\r\n0 <= k <= 109\r\n0 <= prices.length <= 1000\r\n0 <= prices[i] <= 1000\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n可以用递归来算，从根开始，要么买入，要么保持不动。\r\n买入后可以进行的操作有卖出，保持不动\r\n保持不动后的操作有：买入，保持不动\r\n看成二叉树操作，把所有情况算出来(可以用一个备忘录记录下来已经算出来的值)\r\n#### 方法1：递归(会超时)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxProfit(int k, vector<int>& prices) {\r\n        if (k == 0 || prices.size() == 0) {\r\n            return 0;\r\n        }\r\n        return DFS(0, 0, 0, k, prices);\r\n    }\r\n    //计算k次交易，index表示当前是哪天，status是买卖状态，coutnt为交易次数\r\n    int DFS(int index, int status, int count, int k, vector<int>& prices) {\r\n        if (index == prices.size() || count == k) {\r\n            return 0;\r\n        }\r\n        int keep = 0, sell = 0, buy = 0;\r\n        //保持\r\n        keep = DFS(index + 1, status, count, k, prices);\r\n        if (status == 1) {\r\n            //卖出\r\n            sell = DFS(index + 1, 0, count + 1, k, prices) + prices[index];\r\n        }\r\n        else {\r\n            //买入\r\n            buy = DFS(index + 1, 1, count, k, prices) - prices[index];\r\n        }\r\n        return max(max(keep, sell), buy);\r\n    }\r\n};\r\n```\r\n\r\n#### 方法2：递归+记忆\r\n```Java\r\nclass Solution {\r\n    public int maxProfit(int k, int[] prices) {\r\n        if(prices==null || prices.length==0) {\r\n            return 0;\r\n        }\r\n        int n = prices.length;\r\n        //当k非常大时转为无限次交易\r\n        if(k>=n/2) {\r\n            int dp0=0,dp1=-prices[0];\r\n            for(int i=1;i<n;++i) {\r\n                int tmp = dp0;\r\n                dp0 = Math.max(dp0,dp1+prices[i]);\r\n                dp1 = Math.max(dp1,dp0-prices[i]);\r\n            }\r\n            return Math.max(dp0,dp1);\r\n        }\r\n        Map<Key,Integer> cache = new HashMap<Key,Integer>();\r\n        return dfs(cache,0,0,0,k,prices);\r\n    }\r\n\r\n    //带记忆化的 计算k次交易，代码和递归版的一样只是前后加了缓存\r\n    private int dfs(Map<Key,Integer> cache, int index, int status, int count, int k, int[] prices) {\r\n        Key key = new Key(index,status,count);\r\n        if(cache.containsKey(key)) {\r\n            return cache.get(key);\r\n        }\r\n        if(index==prices.length || count==k) {\r\n            return 0;\r\n        }\r\n        int a=0,b=0,c=0;\r\n        a = dfs(cache,index+1,status,count,k,prices);\r\n        if(status==1) {\r\n            b = dfs(cache,index+1,0,count+1,k,prices)+prices[index];\r\n        } else {\r\n            c = dfs(cache,index+1,1,count,k,prices)-prices[index];\r\n        }\r\n        cache.put(key,Math.max(Math.max(a,b),c));\r\n        return cache.get(key);\r\n    }\r\n    //Key对象封装了index、status、交易次数count，作为map的key\r\n    private class Key {\r\n        private final int index;\r\n        private final int status;\r\n        private final int count;\r\n        Key(int index,int status,int count) {\r\n            this.index = index;\r\n            this.status = status;\r\n            this.count = count;\r\n        }\r\n        //这里需要实现自定义的equals和hashCode函数\r\n        public int hashCode() {\r\n            return this.index + this.status + this.count;\r\n        }\r\n        public boolean equals(Object obj) {\r\n            Key other = (Key)obj;\r\n            if(index==other.index && status==other.status && count==other.count) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```",
      "data": {
        "title": "LeetCode 188. 买卖股票的最佳时机 IV(动态规划)(递归)",
        "date": "2020-12-28 15:55:43",
        "tags": [
          "算法",
          "动态规划",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(4).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\r\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\r\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\r",
      "fileName": "leetcode-188-mai-mai-gu-piao-de-zui-jia-shi-ji-ivdong-tai-gui-hua-di-gui"
    },
    {
      "content": "### 题目\r\n给定两个字符串 s 和 t，判断它们是否是同构的。\r\n\r\n如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。\r\n\r\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\r\n<!-- more -->\r\n示例 1:\r\n\r\n输入: s = \"egg\", t = \"add\"\r\n输出: true\r\n示例 2:\r\n\r\n输入: s = \"foo\", t = \"bar\"\r\n输出: false\r\n示例 3:\r\n\r\n输入: s = \"paper\", t = \"title\"\r\n输出: true\r\n说明:\r\n你可以假设 s 和 t 具有相同的长度。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/isomorphic-strings\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n题意为：s中任意一个字符都在t中有唯一对应，t中任意一个字符也都在s中有唯一对应。\r\n所以用两个哈希表一一对应再判断。\r\n```C++\r\nclass Solution {\r\npublic:\r\n    bool isIsomorphic(string s, string t) {\r\n        unordered_map<char, char> map1;\r\n        unordered_map<char, char> map2;\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (map1.find(s[i]) == map1.end()) { // map1保存s[i] 到 t[j]的映射\r\n                map1[s[i]] = t[i];\r\n            }\r\n            if (map2.find(t[i]) == map2.end()) { // map2保存t[j] 到 s[i]的映射\r\n                map2[t[i]] = s[i];\r\n            }\r\n            // 发现映射 对应不上，立刻返回false\r\n            if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "LeetCode 205. 同构字符串(哈希表)",
        "date": "2020-12-27 20:13:39",
        "tags": [
          "算法",
          "LeetCode",
          "哈希表"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/54lqq0%20(1).jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定两个字符串 s 和 t，判断它们是否是同构的。\r\n\r\n如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。\r\n\r\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\r",
      "fileName": "leetcode-205-tong-gou-zi-fu-chuan-ha-xi-biao"
    },
    {
      "content": "### 题目\r\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\r\n\r\n字符          数值\r\nI             1\r\nV             5\r\nX             10\r\nL             50\r\nC             100\r\nD             500\r\nM             1000\r\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\r\n<!-- more -->\r\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\r\n\r\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\r\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \r\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\r\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\r\n\r\n \r\n\r\n示例 1:\r\n\r\n输入: \"III\"\r\n输出: 3\r\n示例 2:\r\n\r\n输入: \"IV\"\r\n输出: 4\r\n示例 3:\r\n\r\n输入: \"IX\"\r\n输出: 9\r\n示例 4:\r\n\r\n输入: \"LVIII\"\r\n输出: 58\r\n解释: L = 50, V= 5, III = 3.\r\n示例 5:\r\n\r\n输入: \"MCMXCIV\"\r\n输出: 1994\r\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\r\n \r\n\r\n提示：\r\n\r\n题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\r\nIC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\r\n关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/roman-to-integer\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n把罗马数字对应的整数存放到一个数组里，对s从头遍历，如果s[i] != reps[j][0]则j++，因为reps是字符串而且要判断的是首字母，所以是reps[j][0]。当s[i] == reps[j][0]时，还需要判断是不是特殊情况比如：四对应的IV，是对应的IX\r\n\r\n`if (reps[j].size() > 1)`则说明reps当前对应的字符串属于特殊情况，`if (i < s.size() - 1 && s[i + 1] == reps[j][1])`说明s当前对应的数字与reps当前对应的数字相匹配，因为一个数占了两个字符所以要i++，j++。再把num累加。\r\n\r\n`if (i < s.size() - 1 && s[i + 1] == reps[j][1])`不满足的情况有可能为s对应IV，reps对应IX，这样虽然前面的I相同但是后面的字符不相同，这种情况就让i不动（因为每次循环结束都会i++，所以先i--），j往后挪一个。\r\n\r\n非特殊情况即`reps[j].size() <= 1`直接将num累加即可\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int romanToInt(string s) {\r\n        if (s.size() == 0) {\r\n            return 0;\r\n        }\r\n        int values[]= {1000,900,500,400,100,90,50,40,10,9,5,4,1};\r\n\t\tstring reps[]= {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\r\n        int j = 0, num = 0;\r\n        for (int i = 0; i < s.size(); i++) {\r\n            while (s[i] != reps[j][0]) {\r\n                j++;\r\n            }\r\n            if (reps[j].size() > 1) {\r\n                if (i < s.size() - 1 && s[i + 1] == reps[j][1]) {\r\n                    i++;\r\n                    num += values[j];\r\n                    j++;\r\n                }\r\n                else {\r\n                    i--;\r\n                    j++;\r\n                }\r\n            }\r\n            else {\r\n                num += values[j];\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "LeetCode 13. 罗马数字转整数(贪心)",
        "date": "2020-12-26 14:16:39",
        "tags": [
          "算法",
          "LeetCode",
          "贪心"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/CV9awWXoCq.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\r\n\r\n字符          数值\r\nI             1\r\nV             5\r\nX             10\r\nL             50\r\nC             100\r\nD             500\r\nM             1000\r\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\r",
      "fileName": "leetcode-13-luo-ma-shu-zi-zhuan-zheng-shu-tan-xin"
    },
    {
      "content": "### 定义\r\n**堆排序**：是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。\r\n\r\n### 概述\r\n若以升序排序说明，把数组转换成最大堆(Max-Heap Heap)，这是一种满足最大堆性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。\r\n重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。\r\n\r\n### 堆节点的访问\r\n通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：\r\n\r\n父节点i的左子节点在位置(2i + 1);\r\n父节点i的右子节点在位置(2i + 2));\r\n子节点i的父节点在位置(i - 1) / 2;\r\n\r\n### 操作\r\n在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：\r\n\r\n - 最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点\r\n - 创建最大堆（Build Max Heap）：将堆中的所有数据重新排序\r\n - 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算\r\n\r\n### 代码实现\r\n```C++\r\n#include <malloc.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nvoid swap(int *a, int *b)\r\n{\r\n    int temp = *b;\r\n    *b = *a;\r\n    *a = temp;\r\n}\r\n\r\nvoid max_heapify(int arr[], int start, int end)\r\n{\r\n    // 建立父节点指标和子节点指标\r\n    int dad = start;\r\n    int son = dad * 2 + 1;\r\n    while (son <= end)\r\n    {                                                  // 若子节点指标在范围内才做比较\r\n        if (son + 1 <= end && arr[son] < arr[son + 1]) // 先比较两个子节点大小，选择最大的\r\n            son++;\r\n        if (arr[dad] > arr[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数\r\n            return;\r\n        else\r\n        { // 否则交换父子内容再继续子节点和孙节点比较\r\n            swap(&arr[dad], &arr[son]);\r\n            dad = son;\r\n            son = dad * 2 + 1;\r\n        }\r\n    }\r\n}\r\n\r\nvoid heap_sort(int arr[], int len)\r\n{\r\n    int i;\r\n    // 初始化，i从最后一个父节点开始调整\r\n    for (i = len / 2 - 1; i >= 0; i--)\r\n        max_heapify(arr, i, len - 1);\r\n    // 先将第一个元素和已排好元素前一位做交换，再重新调整，直到排序完毕\r\n    for (i = len - 1; i > 0; i--)\r\n    {\r\n        swap(&arr[0], &arr[i]);\r\n        max_heapify(arr, 0, i - 1);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    // int arr[] = {9, 10, 5, 11, 12, 7};\r\n    // int len = (int)sizeof(arr) / sizeof(*arr);\r\n\r\n    int len;\r\n    printf(\"输入数组长度\");\r\n    scanf(\"%d\", &len);\r\n    int *arr = (int *)malloc(sizeof(int) * len);\r\n    printf(\"输入数组：\");\r\n    for (int i = 0; i < len; i++)\r\n    {\r\n        scanf(\"%d\", &arr[i]);\r\n    }\r\n    heap_sort(arr, len);\r\n    int i;\r\n    for (i = 0; i < len; i++)\r\n        printf(\"%d \", arr[i]);\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n```\r\n\r\n(来自：维基百科)",
      "data": {
        "title": "堆排序(排序)",
        "date": "2020-12-25 18:02:22",
        "tags": [
          "排序",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/Dl0g4BB4Fp.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "dui-pai-xu"
    },
    {
      "content": "### 题目\r\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\r\n\r\n对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\r\n<!-- more -->\r\n \r\n示例 1:\r\n输入: g = [1,2,3], s = [1,1]\r\n输出: 1\r\n解释: \r\n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\r\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\r\n所以你应该输出1。\r\n\r\n示例 2:\r\n输入: g = [1,2], s = [1,2,3]\r\n输出: 2\r\n解释: \r\n你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\r\n你拥有的饼干数量和尺寸都足以让所有孩子满足。\r\n所以你应该输出2.\r\n \r\n提示：\r\n\r\n1 <= g.length <= 3 * 104\r\n0 <= s.length <= 3 * 104\r\n1 <= g[i], s[j] <= 231 - 1\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/assign-cookies\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n现将孩子胃口数组和饼干尺寸排序，然后遍历孩子胃口，如果孩子胃口大于当前饼干尺寸饼干尺寸指针后移直到当前孩子胃口小于等于当前饼干尺寸\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int findContentChildren(vector<int>& g, vector<int>& s) {\r\n        sort(g.begin(), g.end());\r\n        sort(s.begin(), s.end());\r\n        int n = 0;\r\n        for (int i = 0, j = 0; i < g.size(); i++) {\r\n            while (j < s.size() && g[i] > s[j]) {\r\n                j++;\r\n            }\r\n            if (j < s.size() && g[i] <= s[j]) {\r\n                n++;\r\n                j++;\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "LeetCode 455. 分发饼干(贪心)",
        "date": "2020-12-25 17:05:53",
        "tags": [
          "算法",
          "LeetCode",
          "贪心"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(8).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\r\n\r\n对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\r",
      "fileName": "leetcode-455-fen-fa-bing-gan-tan-xin"
    },
    {
      "content": "### 题目\r\n老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。\r\n\r\n你需要按照以下要求，帮助老师给这些孩子分发糖果：\r\n\r\n每个孩子至少分配到 1 个糖果。\r\n相邻的孩子中，评分高的孩子必须获得更多的糖果。\r\n那么这样下来，老师至少需要准备多少颗糖果呢？\r\n<!-- more -->\r\n示例 1:\r\n\r\n输入: [1,0,2]\r\n输出: 5\r\n解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。\r\n示例 2:\r\n\r\n输入: [1,2,2]\r\n输出: 4\r\n解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。\r\n     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/candy\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n根据题意得出规则：\r\nA在B左边\r\n左规则：``if(ratings[A] < ratings[B])``则B获得糖比A多\r\n右规则：``if(ratings[A] > ratings[B])``则A获得糖比B多\r\n```markdown\r\n1.先从左到右遍历，将每个人得到糖果数记录到left数组中\r\n    1.将left用1填充（给所有学生一个糖果）\r\n    2.``if (ratings[i] > ratings[i - 1])``则``left[i] = left[i - 1] + 1``\r\n    3.``if (ratings[i] < ratings[i - 1])``不变\r\n2.再从右到左遍历，将每个人得到糖果数记录到right数组中，规则满足右规则\r\n3.最终取left[i]和right[i]中最大值，即可同时满足左规则和右规则\r\n```\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int candy(vector<int>& ratings) {\r\n        int num = 0;\r\n        vector<int> left(ratings.size(), 1);\r\n        vector<int> right(ratings.size(), 1);\r\n        for (int i = 1; i < ratings.size(); i++) {\r\n            if (ratings[i] > ratings[i - 1]) {\r\n                left[i] = left[i - 1] + 1;\r\n            }\r\n        }\r\n        for (int i = ratings.size() - 2; i >= 0; i--) {\r\n            if (ratings[i] > ratings[i + 1]) {\r\n                right[i] = right[i + 1] + 1;\r\n            }\r\n        }\r\n        for (int i = 0; i < ratings.size(); i++) {\r\n            num += max(left[i], right[i]);\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "LeetCode 135. 分发糖果(贪心)",
        "date": "2020-12-24 19:14:12",
        "tags": [
          "算法",
          "LeetCode",
          "贪心"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/ycL3yPmxeH.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。\r\n\r\n你需要按照以下要求，帮助老师给这些孩子分发糖果：\r\n\r\n每个孩子至少分配到 1 个糖果。\r\n相邻的孩子中，评分高的孩子必须获得更多的糖果。\r\n那么这样下来，老师至少需要准备多少颗糖果呢？\r",
      "fileName": "leetcode-135-fen-fa-tang-guo-tan-xin"
    },
    {
      "content": "### 题目\r\n假设要把长度为 n 厘米的木棒切分为 1 厘米长的小段，但是 1 根木棒只能由 1 人切分，当木棒被切分为 3 段后，可以同时由 3 个人分别切分木棒（图 2）。\r\n<!-- more -->\r\n![图 2　n ＝ 8，m ＝ 3 的时候](http://www.ituring.com.cn/figures/2017/ProgrammerPuzzle/07.d01z.014.png)\r\n求最多有 m 个人时，最少要切分几次。譬如 n ＝ 8，m＝ 3 时如图所示，切分 4 次就可以了。\r\n\r\n作者：图灵教育\r\n链接：https://leetcode-cn.com/leetbook/read/interesting-algorithm-puzzles-for-programmers/90ach5/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n#### 方法1：DFS\r\n```C++\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint sil(int m, int n, int num) //n要求段数  m人数 num目前段数\r\n{\r\n\tif (num >= n) { //达到要求结束\r\n\t\treturn 0;\r\n\t}\r\n\telse if (num < m) { //目前段数小于人数，直接段数*2\r\n\t\treturn 1 + sil(m, n, num * 2);\r\n\t}\r\n\telse { //目前段数大于等于人数，增加m段\r\n\t\treturn 1 + sil(m, n, num + m);\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\tcout<<sil(3, 20, 1)<<endl<<sil(5, 100, 1);\r\n\treturn 0;\r\n}\r\n```\r\n#### 方法2：BFS\r\n```C++\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint sil(int m, int n, int num) //n要求段数  m人数 num目前段数\r\n{\r\n\tint count = 0;\r\n\twhile (num < n) {\r\n\t\tnum += num < m ? num : m;\r\n        /*\r\n\t\tif (num < m) {\r\n\t\t\tnum += num;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnum += m;\r\n\t\t}\r\n\t\tcount++;\r\n\t\t*/\r\n\t\tcount++;\r\n\t}\r\n\treturn count;\r\n}\r\n\r\nint main()\r\n{\r\n\tcout<<sil(3, 20, 1)<<endl<<sil(5, 100, 1);\r\n\treturn 0;\r\n}\r\n```",
      "data": {
        "title": "切分木棒(DFS)(BFS)",
        "date": "2020-12-24 17:29:49",
        "tags": [
          "算法",
          "搜索"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/PzudLoS8IG.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n假设要把长度为 n 厘米的木棒切分为 1 厘米长的小段，但是 1 根木棒只能由 1 人切分，当木棒被切分为 3 段后，可以同时由 3 个人分别切分木棒（图 2）。\r",
      "fileName": "qie-fen-mu-bang-dfsbfs"
    },
    {
      "content": "### 题目\r\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\r\n<!-- more -->\r\n示例：\r\n\r\ns = \"leetcode\"\r\n返回 0\r\n\r\ns = \"loveleetcode\"\r\n返回 2\r\n \r\n\r\n提示：你可以假定该字符串只包含小写字母。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n#### 方法1：哈希表\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int firstUniqChar(string s) {\r\n        if (s.size() <= 0) {\r\n            return -1;\r\n        }\r\n        map<int, int> smap;\r\n        for (char ch : s) {\r\n            smap[ch]++;\r\n        }\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (smap[s[i]] == 1) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```\r\n#### 方法2：数组\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int firstUniqChar(string s) {\r\n        int map[26] = {0};\r\n        for (int i = 0; i < s.size(); i++) {\r\n            map[s[i] - 'a']++;\r\n        }\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (map[s[i] - 'a'] == 1) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "LeetCode 387. 字符串中的第一个唯一字符(哈希表)",
        "date": "2020-12-23 19:54:29",
        "tags": [
          "算法",
          "LeetCode",
          "哈希表"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/gridea-zhu-ti-fog-geng-xin-ri-zhi.jpeg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\r",
      "fileName": "leetcode-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu-ha-xi-biao"
    },
    {
      "content": "### 题目\r\n罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\r\n\r\n字符          数值\r\nI             1\r\nV             5\r\nX             10\r\nL             50\r\nC             100\r\nD             500\r\nM             1000\r\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\r\n<!-- more -->\r\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\r\n\r\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\r\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \r\nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\r\n给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。\r\n\r\n示例 1:\r\n\r\n输入: 3\r\n输出: \"III\"\r\n示例 2:\r\n\r\n输入: 4\r\n输出: \"IV\"\r\n示例 3:\r\n\r\n输入: 9\r\n输出: \"IX\"\r\n示例 4:\r\n\r\n输入: 58\r\n输出: \"LVIII\"\r\n解释: L = 50, V = 5, III = 3.\r\n示例 5:\r\n\r\n输入: 1994\r\n输出: \"MCMXCIV\"\r\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/integer-to-roman\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n#### 方法1:暴力解法\r\n把每种情况都写出来然后直接暴力解决\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string five(int num) {\r\n        string str;\r\n         if (num == 4) {\r\n                str = \"IV\";\r\n        }\r\n        else if (num == 5) {\r\n            str = \"V\";\r\n        }\r\n        else {\r\n            for (int i = 0; i < num; i++) {\r\n                str += 'I';\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n\r\n    string ten(int num) {\r\n        string str;\r\n        if (num == 9) {\r\n            str = \"IX\";\r\n        }\r\n        else if (num == 10) {\r\n            str = \"X\";\r\n        }\r\n        else {\r\n            str = \"V\";\r\n            for (int i = 0; i < num - 5; i++) {\r\n                str += 'I';\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n\r\n    string fifty(int num) {\r\n        string str;\r\n        if (num == 40) {\r\n            str = \"XL\";\r\n        }\r\n        else if (num == 50) {\r\n            str = \"L\";\r\n        }\r\n        else if (num > 40) {\r\n            str = \"XL\";\r\n            int n = num - 40;\r\n            if (n > 5) {\r\n                str += ten(n);\r\n            }\r\n            else {\r\n                str += five(n);\r\n            }\r\n        }\r\n        else {\r\n            int n = num / 10;\r\n            num %= 10;\r\n            for (int i = 0; i < n; i++) {\r\n                str += 'X';\r\n            }\r\n            if (num <= 5) {\r\n                str += five(num);\r\n            }\r\n            else {\r\n                str += ten(num);\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n\r\n    string hundred(int num) {\r\n        string str;\r\n        if (num == 90) {\r\n            str = \"XC\";\r\n        }\r\n        else if (num == 100) {\r\n            str = \"C\";\r\n        }\r\n        else if (num > 90) {\r\n            str = \"XC\";\r\n            int n = num - 90;\r\n            if (n > 5) {\r\n                str += ten(n);\r\n            }\r\n            else {\r\n                str += five(n);\r\n            }            \r\n        }\r\n        else {\r\n            str = \"L\";\r\n            num -= 50;\r\n            int n = num / 10;\r\n            num %= 10;\r\n            for (int i = 0; i < n; i++) {\r\n                str += 'X';\r\n            }\r\n            if (num <= 5) {\r\n                str += five(num);\r\n            }\r\n            else {\r\n                str += ten(num);\r\n            }            \r\n        }\r\n        return str;\r\n    }\r\n\r\n    string fiveh(int num) {\r\n        string str;\r\n        if (num == 400) {\r\n            str = \"CD\";\r\n        }\r\n        else if (num == 500) {\r\n            str = \"D\";\r\n        }\r\n        else if (num > 400) {\r\n            str = \"CD\";\r\n            int n = num - 400;\r\n            if (n > 50) {\r\n                str += hundred(n);\r\n            }\r\n            else {\r\n                str += fifty(n);\r\n            }\r\n        }\r\n        else {\r\n            int n = num / 100;\r\n            num %= 100;\r\n            for (int i = 0; i < n; i++) {\r\n                str += 'C';\r\n            }\r\n            if (num > 50) {\r\n                str += hundred(num);\r\n            }\r\n            else {\r\n                str += fifty(num);\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n\r\n    string thousand(int num) {\r\n        string str;\r\n        if (num == 900) {\r\n            str = \"CM\";\r\n        }\r\n        else if (num == 1000) {\r\n            str = \"M\";\r\n        }\r\n        else if (num > 900) {\r\n            str = \"CM\";\r\n            int n = num - 900;\r\n            // cout<<num;\r\n            if (n > 50) {\r\n                str += hundred(n);\r\n            }\r\n            else {\r\n                str += fifty(n);\r\n            }\r\n        }\r\n        else {\r\n            str = \"D\";\r\n            num -= 500;\r\n            int n = num / 100;\r\n            num %= 100;\r\n            // cout<<num;\r\n            for (int i = 0; i < n; i++) {\r\n                str += \"C\";\r\n            }\r\n            if (num > 50) {\r\n                str += hundred(num);\r\n            }\r\n            else {\r\n                // cout<<num<<\" \"<<fifty(num);\r\n                str += fifty(num);\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n\r\n    string more(int num) {\r\n        string str;\r\n        int n = num / 1000;\r\n        num %= 1000;\r\n        for (int i = 0; i < n; i++) {\r\n            str += \"M\";\r\n        }\r\n        if (num <= 5) {\r\n            str += five(num);\r\n        }\r\n        else if (num <= 10) {\r\n            str += ten(num);\r\n        }\r\n        else if (num <= 50) {\r\n            str += fifty(num);\r\n        }\r\n        else if (num <= 100) {\r\n            str += hundred(num);\r\n        }\r\n        else if (num <= 500) {\r\n            str += fiveh(num);\r\n        }\r\n        else if (num <= 1000) {\r\n            str += thousand(num);\r\n        }\r\n        return str;\r\n    }\r\n\r\n    string intToRoman(int num) {\r\n        string str = \"\";\r\n        if (num > 0) {\r\n            if (num <= 5) {\r\n                str += five(num);\r\n            }\r\n            else if (num <= 10) {\r\n                str += ten(num);\r\n            }\r\n            else if (num <= 50) {\r\n                str += fifty(num);\r\n            }\r\n            else if (num <= 100) {\r\n                str += hundred(num);\r\n            }\r\n            else if (num <= 500) {\r\n                str += fiveh(num);\r\n            }\r\n            else if (num <= 1000) {\r\n                str += thousand(num);\r\n            }\r\n            else {\r\n                str += more(num);\r\n            }\r\n        }\r\n        else {\r\n            str = \"\";\r\n        }\r\n        return str;\r\n    }\r\n};\r\n```\r\n#### 方法2:贪心算法\r\n把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中，并且按照阿拉伯数字的大小降序排列。每次尽可能优先使用较大数值对应的字符\r\n```C++\r\nclass Solution {\r\npublic:\r\n\tstring intToRoman(int num) {\r\n\t\tint values[]= {1000,900,500,400,100,90,50,40,10,9,5,4,1};\r\n\t\tstring reps[]= {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\r\n\t\tstring res;\r\n\t\tfor(int i=0; i<13; i++) {\r\n\t\t\twhile(num>=values[i]) {\r\n\t\t\t\tnum -= values[i];\r\n\t\t\t\tres += reps[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n};\r\n```",
      "data": {
        "title": "LeetCode 12. 整数转罗马数字(字符串)(贪心算法)",
        "date": "2020-12-22 19:15:18",
        "tags": [
          "算法",
          "贪心",
          "字符串",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/Dl0g4BB4Fp.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\r\n\r\n字符          数值\r\nI             1\r\nV             5\r\nX             10\r\nL             50\r\nC             100\r\nD             500\r\nM             1000\r\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\r",
      "fileName": "leetcode-12-zheng-shu-zhuan-luo-ma-shu-zi-zi-fu-chuan"
    },
    {
      "content": "### 题目\r\n实现 int sqrt(int x) 函数。\r\n计算并返回 x 的平方根，其中 x 是非负整数。\r\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\r\n<!-- more -->\r\n示例 1:\r\n\r\n输入: 4\r\n输出: 2\r\n示例 2:\r\n\r\n输入: 8\r\n输出: 2\r\n说明: 8 的平方根是 2.82842..., \r\n     由于返回类型是整数，小数部分将被舍去。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/sqrtx\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n采用二分法每次找到中间元素与x比较大小，大则在左边查找，小则在右边查找\r\n每次判断一下lo（最左边元素）的平方与lo + 1的平方：\r\n``if (pow(hi, 2) < x && pow(hi + 1, 2) > x)``这就说明x平方根是lo到lo + 1之间的值，所以直接返回lo即可\r\n判断hi同理\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int res = 0;\r\n    void Sqrt(int lo, int hi, int x) {\r\n        if (pow(lo, 2) == x) {\r\n            res = lo;\r\n            return;\r\n        }\r\n        else if (pow(hi, 2) == x) {\r\n            res = hi;\r\n            return;\r\n        }\r\n        else if (pow(lo, 2) < x && pow(lo + 1, 2) > x) {\r\n            res = lo;\r\n            return;\r\n        }\r\n        else if (pow(hi, 2) < x && pow(hi + 1, 2) > x) {\r\n            res = hi;\r\n            return;\r\n        }\r\n        else if (pow((lo + hi) / 2, 2) == x) {\r\n            res = (lo + hi) / 2;\r\n            return;\r\n        }\r\n        else if (pow((lo + hi) / 2, 2) < x) {\r\n            lo = (lo + hi) / 2;\r\n            Sqrt(lo, hi, x);\r\n        }\r\n        else if (pow((lo + hi) / 2, 2) > x) {\r\n            hi = (lo + hi) / 2;\r\n            Sqrt(lo, hi, x);\r\n        }\r\n    }\r\n    int mySqrt(int x) {\r\n        int lo = 0, hi = x;\r\n        Sqrt(lo, hi, x);\r\n        return res;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "LeetCode 69. x 的平方根(二分)",
        "date": "2020-12-21 17:32:31",
        "tags": [
          "算法",
          "二分",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(1).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n实现 int sqrt(int x) 函数。\r\n计算并返回 x 的平方根，其中 x 是非负整数。\r\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\r",
      "fileName": "leetcode-69-x-de-ping-fang-gen-er-fen"
    },
    {
      "content": "```C\r\n#include <Windows.h>\r\n#include <math.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define N 50\r\n\r\n//进制转换\r\n\r\nchar *Ten_MoreThanTen(int, int); //10进制数转换成10以上进制数的函数\r\n\r\nint MoreThanTen_Ten(int, char[]); //10以上进制数转换成10进制数的函数\r\n\r\nint Ten_LessThanTen(int, int); //10进制数转换成10以内进制数的函数\r\n\r\nint LessThanTen_Ten(int, int); //10以内进制数转换成10进制数的函数\r\n\r\nchar array[N] = \"\\0\"; //全局变量，用于存储转换后并且倒置了的数据\r\n\r\nint LessThanTen_Ten(int before, int num) //10以内转换10，参数brfore为初始进制,num为初始数值\r\n\r\n{\r\n\r\n    double result = 0.0; //转换成10进制后的结果\r\n\r\n    int i = 0;\r\n\r\n    for (i = 0; num != 0; i++) //利用for循环实现按权展开相加\r\n\r\n    {\r\n\r\n        result += pow(before, i) * (num % 10);\r\n\r\n        num /= 10;\r\n    }\r\n\r\n    return (int)result; //返回值为转换后的结果\r\n}\r\n\r\nint Ten_LessThanTen(int after, int num) //10转换10以内，参数after为转换后的进制，num为10进制数值\r\n\r\n{\r\n\r\n    double result = 0.0; //double类型因为pow函数的返回值为double类型\r\n\r\n    int i = 0;\r\n\r\n    for (i = 0; num != 0; i++) //利用for循环实现连续取余\r\n\r\n    {\r\n\r\n        result += (num % after) * pow(10, i);\r\n\r\n        num /= after;\r\n    }\r\n\r\n    return (int)result;\r\n}\r\n\r\nint MoreThanTen_Ten(int before, char num[]) //10以上转换10\r\n\r\n{\r\n\r\n    int i = 0;\r\n\r\n    double result = 0.0;\r\n\r\n    int length = strlen(num);\r\n\r\n    for (i = length - 1; i >= 0; i--)\r\n\r\n    {\r\n\r\n        //利用ASCALL码将所有元素转换成对应的整型\r\n\r\n        if ('A' <= num[i] && num[i] <= 'Z')\r\n\r\n            result += pow(before, length - i - 1) * (num[i] - 55);\r\n\r\n        else if ('a' <= num[i] && num[i] <= 'z')\r\n\r\n            result += pow(before, length - i - 1) * (num[i] - 87);\r\n\r\n        else if ('0' <= num[i] && num[i] <= '9')\r\n\r\n            result += pow(before, length - i - 1) * (num[i] - 48);\r\n    }\r\n\r\n    return (int)result;\r\n}\r\n\r\nchar *Ten_MoreThanTen(int after, int num) //10转换10以上\r\n\r\n{\r\n\r\n    int i = 0;\r\n\r\n    int j = 0;\r\n\r\n    int tmp = 0; //存储每次余数的中间变量\r\n\r\n    char tmp_array[N] = \"\\0\"; //转换后未倒置的数组\r\n\r\n    for (i = 0; num > 0; i++)\r\n\r\n    {\r\n\r\n        tmp = num % after;\r\n\r\n        if (tmp < 10) //对大于等于10的余数进行字母转换\r\n\r\n            tmp_array[i] = tmp + '0';\r\n\r\n        else\r\n\r\n            tmp_array[i] = tmp + 'A' - 10;\r\n\r\n        num /= after;\r\n    }\r\n\r\n    for (j = 0; i > 0; i--, j++) //倒置\r\n\r\n    {\r\n\r\n        array[j] = tmp_array[i - 1];\r\n\r\n        array[j + 1] = '\\0';\r\n    }\r\n\r\n    return array; //输出转换后存储数据的字符串地址\r\n}\r\n\r\nint main()\r\n\r\n{\r\n\r\n    int before = 0; //转换前的进制数\r\n\r\n    int after = 0; //转换后的进制数\r\n\r\n    int num1 = 0; //要转换的十进制以内的数\r\n\r\n    char array_num1[N] = \"\\0\"; //要转换的十进制以上的数\r\n\r\n    int num2 = 0; //转换之后的数\r\n\r\n    char *str_num2; //转换之后的数的地址\r\n\r\n    int tmp_num1 = 0; //判断输入是否合法时代替num1的中间变量\r\n\r\n    int i = 0;\r\n\r\n    int m = 0; //计数器\r\n\r\n    while (1) //整个while语句用于录入以及判断输入是否合法\r\n\r\n    {\r\n\r\n        printf(\"初始进制：\");\r\n\r\n        scanf(\"%d\", &before);\r\n\r\n        printf(\"目标进制：\");\r\n\r\n        scanf(\"%d\", &after);\r\n\r\n        printf(\"初始数值：\");\r\n\r\n        if (before > 10) //通过对初始进制判断，决定\r\n\r\n            scanf(\"%s\", array_num1);\r\n\r\n        else\r\n\r\n            scanf(\"%d\", &num1);\r\n\r\n        for (i = 0, tmp_num1 = num1; tmp_num1 != 0; i++)\r\n\r\n        {\r\n\r\n            if ((tmp_num1 % 10) <= before && tmp_num1 % 10 >= 0 && tmp_num1 % 10 <= 9)\r\n\r\n                m++;\r\n\r\n            tmp_num1 /= 10;\r\n        }\r\n\r\n        if (m == i) //判断输入的数据每一位是否都小于等于进制数\r\n\r\n            break;\r\n\r\n        else\r\n\r\n        {\r\n\r\n            m = 0; //对计数器m重新初始化\r\n\r\n            fflush(stdin); //清空缓存区\r\n\r\n            printf(\"输入有误！请重新输入：\\n\");\r\n        }\r\n    }\r\n\r\n    //将进制转换的四种情况分别表示\r\n\r\n    if (before <= 10 && after <= 10)\r\n\r\n    {\r\n\r\n        num2 = Ten_LessThanTen(after, LessThanTen_Ten(before, num1));\r\n\r\n        printf(\"\\n%d进制的%d对应的%d进制数为：%d\\n\", before, num1, after, num2);\r\n    }\r\n\r\n    else if (before > 10 && after <= 10)\r\n\r\n    {\r\n\r\n        num2 = Ten_LessThanTen(after, MoreThanTen_Ten(before, array_num1));\r\n\r\n        printf(\"\\n%d进制的%s对应的%d进制数为：%d\\n\", before, array_num1, after, num2);\r\n    }\r\n\r\n    else if (before <= 10 && after > 10)\r\n\r\n    {\r\n\r\n        str_num2 = Ten_MoreThanTen(after, LessThanTen_Ten(before, num1));\r\n\r\n        printf(\"\\n%d进制的%d对应的%d进制数为：%s\\n\", before, num1, after, str_num2);\r\n    }\r\n\r\n    else if (before > 10 && after > 10)\r\n\r\n    {\r\n\r\n        str_num2 = Ten_MoreThanTen(after, MoreThanTen_Ten(before, array_num1));\r\n\r\n        printf(\"\\n%d进制的%s对应的%d进制数为：%s\\n\", before, array_num1, after, str_num2);\r\n    }\r\n\r\n    system(\"pause\");\r\n\r\n    return 0;\r\n}\r\n```",
      "data": {
        "title": "C语言实现各种进制之间转换",
        "date": "2020-12-20 19:55:47",
        "tags": [
          "C/C++"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/ycL3yPmxeH.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "c-yu-yan-shi-xian-ge-chong-jin-zhi-zhi-jian-zhuan-huan"
    },
    {
      "content": "### 题目\r\n给定一个 n × n 的二维矩阵表示一个图像。\r\n将图像顺时针旋转 90 度。\r\n<!-- more -->\r\n说明：\r\n\r\n你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\r\n\r\n示例 1:\r\n\r\n给定 matrix = \r\n[\r\n  [1,2,3],\r\n  [4,5,6],\r\n  [7,8,9]\r\n],\r\n\r\n原地旋转输入矩阵，使其变为:\r\n[\r\n  [7,4,1],\r\n  [8,5,2],\r\n  [9,6,3]\r\n]\r\n示例 2:\r\n\r\n给定 matrix =\r\n[\r\n  [ 5, 1, 9,11],\r\n  [ 2, 4, 8,10],\r\n  [13, 3, 6, 7],\r\n  [15,14,12,16]\r\n], \r\n\r\n原地旋转输入矩阵，使其变为:\r\n[\r\n  [15,13, 2, 5],\r\n  [14, 3, 4, 1],\r\n  [12, 6, 8, 9],\r\n  [16, 7,10,11]\r\n]\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/rotate-image\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n#### 方法1\r\n**题目要求不要用辅助数组，此题解用了辅助数组**\r\n直接用一个辅助数组arr，arr的列是matrix的行，用两个循环即可\r\n```C++\r\nclass Solution {\r\npublic:\r\n    void rotate(vector<vector<int>>& matrix) {\r\n        vector<vector<int>> arr = matrix;\r\n        for (int i = 0, j = matrix.size() - 1; i < matrix.size(); i++, j--) {\r\n            for (int m = 0; m < matrix[i].size(); m++) {\r\n                arr[m][j] = matrix[i][m];\r\n            }\r\n        }\r\n        matrix = arr;\r\n    }\r\n};\r\n```\r\n#### 方法2\r\n可以先对数组进行从左上到右下对角线为轴进行翻转，再对每一行以中间为轴翻转。即可\r\n```C++\r\nclass Solution {\r\npublic:\r\n    void rotate(vector<vector<int>>& matrix) {\r\n        if (matrix.size() == 0) {\r\n            return;\r\n        }\r\n        int i, j, m, temp;\r\n        for (i = 0; i < matrix.size() - 1; i++) {\r\n            for (j = i + 1; j < matrix.size(); j++) {\r\n                temp = matrix[i][j];\r\n                matrix[i][j] = matrix[j][i];\r\n                matrix[j][i] = temp;\r\n            }\r\n        }\r\n        for (i = 0; i < matrix.size(); i++) {\r\n            for (j = matrix[i].size() / 2; j < matrix.size(); j++) {\r\n                temp = matrix[i][j];\r\n                matrix[i][j] = matrix[i][matrix.size() - j - 1];\r\n                matrix[i][matrix.size() - j - 1] = temp;\r\n            }\r\n        }\r\n    }\r\n};\r\n```",
      "data": {
        "title": "旋转图像(数组)",
        "date": "2020-12-19 18:45:03",
        "tags": [
          "算法",
          "数组",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(3).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个 n × n 的二维矩阵表示一个图像。\r\n将图像顺时针旋转 90 度。\r",
      "fileName": "xuan-zhuan-tu-xiang-shu-zu"
    },
    {
      "content": "# 生成目录\r\n在markdown顶部输入`[TOC]`即可生成目录\r\n# Markdown标题\r\nMarkdown标题有两种\r\n## 第一种标题\r\n使用=和-标记\r\n\r\n```markdown\r\n我展示的是一级标题\r\n=================\r\n\r\n我展示的是二级标题\r\n-----------------\r\n```\r\n\r\n## 第二种标题\r\n使用#标记\r\n\r\n```markdown\r\n# 一级标题\r\n## 二级标题\r\n### 三级标题\r\n#### 四级标题\r\n##### 五级标题\r\n###### 六级标题\r\n```\r\n\r\n# Markdown 段落格式\r\n## Markdown 段落\r\nMarkdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。或者\r\n\r\n```markdown\r\n<br><br>\r\n```\r\n\r\n## 字体\r\n\r\n```markdown\r\n*斜体文本*\r\n_斜体文本_\r\n**粗体文本**\r\n__粗体文本__\r\n***粗斜体文本***\r\n___粗斜体文本___\r\n```\r\n\r\n*斜体文本*\r\n_斜体文本_\r\n**粗体文本**\r\n__粗体文本__\r\n***粗斜体文本***\r\n___粗斜体文本___\r\n\r\n## 分隔线\r\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\r\n\r\n```markdown\r\n***\r\n\r\n* * *\r\n\r\n*****\r\n\r\n- - -\r\n\r\n----------\r\n```\r\n\r\n## 删除线\r\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ``~~`` 即可，实例如下：\r\n\r\n```markdown\r\nRUNOOB.COM\r\nGOOGLE.COM\r\n~~BAIDU.COM~~\r\n```\r\n\r\nRUNOOB.COM\r\nGOOGLE.COM\r\n~~BAIDU.COM~~\r\n\r\n## 下划线\r\n\r\n下划线可以通过 HTML 的`` <u>`` 标签来实现：\r\n\r\n```markdown\r\n<u>带下划线文本</u>\r\n```\r\n\r\n<u>带下划线文本</u>\r\n\r\n## 脚注\r\n\r\n脚注是对文本的补充说明。\r\n\r\nMarkdown 脚注的格式如下:\r\n\r\n```markdown\r\n[^要注明的文本]\r\n```\r\n\r\n以下实例演示了脚注的用法：\r\n\r\n```markdown\r\n创建脚注格式类似这样 [^RUNOOB]。\r\n\r\n[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！\r\n```\r\n\r\n创建脚注格式类似这样 [^RUNOOB]。\r\n\r\n[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！\r\n\r\n# Markdown 列表\r\n## 无序列表\r\nMarkdown 支持有序列表和无序列表。\r\n无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：\r\n\r\n```markdown\r\n* 第一项\r\n* 第二项\r\n* 第三项\r\n\r\n+ 第一项\r\n+ 第二项\r\n+ 第三项\r\n\r\n- 第一项\r\n- 第二项\r\n- 第三项\r\n```\r\n\r\n* 第一项\r\n* 第二项\r\n* 第三项\r\n\r\n+ 第一项\r\n+ 第二项\r\n+ 第三项\r\n\r\n\r\n- 第一项\r\n- 第二项\r\n- 第三项\r\n\r\n## 有序列表\r\n有序列表使用数字并加上 . 号来表示，如：\r\n```markdown\r\n1. 第一项\r\n2. 第二项\r\n3. 第三项\r\n```\r\n1. 第一项\r\n2. 第二项\r\n3. 第三项\r\n\r\n## 列表嵌套\r\n列表嵌套只需在子列表中的选项前面添加四个空格即可：\r\n```markdown\r\n1. 第一项：\r\n    - 第一项嵌套的第一个元素\r\n    - 第一项嵌套的第二个元素\r\n2. 第二项：\r\n    - 第二项嵌套的第一个元素\r\n    - 第二项嵌套的第二个元素\r\n   \r\n```\r\n1. 第一项：\r\n    - 第一项嵌套的第一个元素\r\n    - 第一项嵌套的第二个元素\r\n2. 第二项：\r\n    - 第二项嵌套的第一个元素\r\n    - 第二项嵌套的第二个元素\r\n\r\n# Markdown 区块\r\nMarkdown 区块引用是在段落开头使用 > 符号 ，然后后面紧跟一个空格符号：\r\n```markdown\r\n> 区块引用\r\n> 菜鸟教程\r\n> 学的不仅是技术更是梦想\r\n```\r\n> 区块引用\r\n> 菜鸟教程\r\n> 学的不仅是技术更是梦想\r\n\r\n另外区块是可以嵌套的，一个 > 符号是最外层，两个 > 符号是第一层嵌套，以此类推：\r\n```markdown\r\n> 最外层\r\n> > 第一层嵌套\r\n> > > 第二层嵌套\r\n```\r\n> 最外层\r\n> > 第一层嵌套\r\n> >\r\n> > > 第二层嵌套  \r\n\r\n## 区块中使用列表\r\n区块中使用列表实例如下:\r\n```markdown\r\n> 区块中使用列表\r\n> 1. 第一项\r\n> 2. 第二项\r\n> + 第一项\r\n> + 第二项\r\n> + 第三项\r\n```\r\n> 区块中使用列表\r\n> 1. 第一项\r\n> 2. 第二项\r\n> + 第一项\r\n> + 第二项\r\n> + 第三项\r\n\r\n## 列表中使用区块\r\n如果要在列表项目内放进区块，那么就需要在 > 前添加四个空格的缩进。\r\n区块中使用列表实例如下：\r\n```markdown\r\n* 第一项\r\n    > 菜鸟教程\r\n    > 学的不仅是技术更是梦想\r\n* 第二项\r\n```\r\n* 第一项\r\n    > 菜鸟教程\r\n    > 学的不仅是技术更是梦想\r\n* 第二项\r\n\r\n# Markdown 代码\r\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来``（`）``，例如：\r\n```markdown\r\n`printf()` 函数\r\n```\r\n`printf()` 函数\r\n\r\n## 代码区块\r\n代码区块使用 4 个空格或者一个制表符（Tab 键）。\r\n\r\n实例如下：\r\n\tprintf(\"hello\")\r\n\r\n\r\n你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：\r\n```markdown\r\n​```javascript\r\n$(document).ready(function () {\r\n    alert('hello word!');\r\n});\r\n​```\r\n```\r\n```javascript\r\n$(document).ready(function () {\r\n    alert('hello word!');\r\n});\r\n```\r\n\r\n# Markdown 链接\r\n链接使用方法如下：\r\n```markdown\r\n[链接名称](链接地址)\r\n\r\n或者\r\n\r\n<链接地址>\r\n```\r\n[blog](https://sakuratears.cn)\r\n\r\n或者\r\n\r\n<https://sakuratears.cn>\r\n\r\n## 高级链接\r\n我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：\r\n```markdown\r\n这个链接用 1 作为网址变量 [Google][1]\r\n这个链接用 sakura 作为网址变量 [sakura][sakura]\r\n然后在文档的结尾为变量赋值（网址）\r\n\r\n  [1]: http://www.google.com/\r\n  [sakura]: https://sakuratears.cn/\r\n```\r\n\r\n这个链接用 1 作为网址变量 [Google][1]\r\n这个链接用 sakura 作为网址变量 [sakura][sakura]\r\n然后在文档的结尾为变量赋值（网址）\r\n\r\n[1]: http://www.google.com/\r\n[sakura]: https://sakuratears.cn/\r\n\r\n# Markdown 图片\r\nMarkdown 图片语法格式如下：\r\n```markdown\r\n![alt 属性文本](图片地址)\r\n\r\n![alt 属性文本](图片地址 \"可选标题\")\r\n```\r\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)\r\n\r\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png \"RUNOOB\")\r\n\r\n当然，你也可以像网址那样对图片网址使用变量:\r\n```markdown\r\n这个链接用 1 作为网址变量 [RUNOOB][1].\r\n然后在文档的结尾为变量赋值（网址）\r\n\r\n[1]: http://static.runoob.com/images/runoob-logo.png\r\n```\r\n这个链接用 1 作为网址变量 [RUNOOB][1].\r\n然后在文档的结尾为变量赋值（网址）\r\n\r\n[1]: http://static.runoob.com/images/runoob-logo.png\r\n\r\nMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。\r\n```markdown\r\n<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\">\r\n```\r\n<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\">\r\n\r\n# Markdown 表格\r\nMarkdown 制作表格使用 `| `来分隔不同的单元格，使用` -` 来分隔表头和其他行。\r\n语法格式如下：\r\n```markdown\r\n|  表头   | 表头  |\r\n|  ----  | ----  |\r\n| 单元格  | 单元格 |\r\n| 单元格  | 单元格 |\r\n```\r\n对齐方式\r\n\r\n我们可以设置表格的对齐方式：\r\n\r\n`-: ` 设置内容和标题栏居右对齐。\r\n`:- `设置内容和标题栏居左对齐。\r\n`:-: `设置内容和标题栏居中对齐。\r\n```markdown\r\n| 左对齐 | 右对齐 | 居中对齐 |\r\n| :-----| ----: | :----: |\r\n| 单元格 | 单元格 | 单元格 |\r\n| 单元格 | 单元格 | 单元格 |\r\n```\r\n| 左对齐 | 右对齐 | 居中对齐 |\r\n| :-----| ----: | :----: |\r\n| 单元格 | 单元格 | 单元格 |\r\n| 单元格 | 单元格 | 单元格 |\r\n\r\n# Markdown 高级技巧\r\n## 支持的 HTML 元素\r\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\r\n\r\n目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：\r\n```markdown\r\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\r\n```\r\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\r\n\r\n## 转义\r\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\r\n```markdown\r\n**文本加粗** \r\n\\*\\* 正常显示星号 \\*\\*\r\n```\r\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\r\n```markdown\r\n\\   反斜线\r\n`   反引号\r\n*   星号\r\n_   下划线\r\n{}  花括号\r\n[]  方括号\r\n()  小括号\r\n#   井字号\r\n+   加号\r\n-   减号\r\n.   英文句点\r\n!   感叹号\r\n```\r\n\r\n## 公式\r\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\r\n```markdown\r\n$$\r\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix} \r\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\r\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\r\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\r\n\\end{vmatrix}\r\n${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\r\n$$\r\n```\r\n$$\r\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix} \r\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\r\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\r\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\r\n\\end{vmatrix}\r\n${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\r\n$$\r\n",
      "data": {
        "title": "Markdown语法",
        "date": "2020-12-18 21:26:30",
        "tags": [
          "日常使用"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/CV9awWXoCq.jpg",
        "isTop": true
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "markdown-yu-fa"
    },
    {
      "content": "### 题目\r\n给定两个字符串 s 和 t，它们只包含小写字母。\r\n字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。\r\n请找出在 t 中被添加的字母。\r\n<!-- more -->\r\n \r\n\r\n示例 1：\r\n输入：s = \"abcd\", t = \"abcde\"\r\n输出：\"e\"\r\n解释：'e' 是那个被添加的字母。\r\n\r\n示例 2：\r\n输入：s = \"\", t = \"y\"\r\n输出：\"y\"\r\n\r\n示例 3：\r\n输入：s = \"a\", t = \"aa\"\r\n输出：\"a\"\r\n\r\n示例 4：\r\n输入：s = \"ae\", t = \"aea\"\r\n输出：\"a\"\r\n \r\n提示：\r\n\r\n0 <= s.length <= 1000\r\nt.length == s.length + 1\r\ns 和 t 只包含小写字母\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/find-the-difference\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n#### 方法1：位运算\r\n^运算符：0与任何数ch做^运算都是ch\r\n相同字符异或为0\r\n\r\n因为t中的字符是s + ch，所以s与t做异或剩下的就是ch\r\n```C++\r\nclass Solution {\r\npublic:\r\n    char findTheDifference(string s, string t) {\r\n        char res = 0;\r\n        for(char c : s + t) {\r\n            res ^= c;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n#### 方法2：哈希表\r\n把s中所有元素存到一个哈希表mpS里，t中所有元素存到一个哈希表mpT里\r\n然后比较两个哈希表每个元素个数，不一样的就是题目所求\r\n```C++\r\nchar findTheDifference(string s, string t) {\r\n        unordered_map<char, int> mpS;\r\n        unordered_map<char, int> mpT;\r\n        char ch;\r\n        for (auto ch : s) {\r\n            mpS[ch]++;\r\n        }\r\n        for (auto ch : t) {\r\n            mpT[ch]++;\r\n        }\r\n\r\n        for (ch = 'a'; ch <= 'z'; ch++) {\r\n            if (mpS[ch] != mpT[ch]) {\r\n                return ch;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n    ```",
      "data": {
        "title": "找不同(位运算)(哈希表)",
        "date": "2020-12-18 17:38:22",
        "tags": [
          "算法",
          "LeetCode",
          "位运算",
          "哈希表"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/Dl0g4BB4Fp.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定两个字符串 s 和 t，它们只包含小写字母。\r\n字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。\r\n请找出在 t 中被添加的字母。\r",
      "fileName": "zhao-bu-tong-wei-yun-suan-ha-xi-biao"
    },
    {
      "content": "### 题目\r\n编写一个函数来查找字符串数组中的最长公共前缀。\r\n\r\n如果不存在公共前缀，返回空字符串 \"\"。\r\n<!-- more -->\r\n示例 1:\r\n\r\n输入: [\"flower\",\"flow\",\"flight\"]\r\n输出: \"fl\"\r\n示例 2:\r\n\r\n输入: [\"dog\",\"racecar\",\"car\"]\r\n输出: \"\"\r\n解释: 输入不存在公共前缀。\r\n说明:\r\n\r\n所有输入只包含小写字母 a-z 。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/longest-common-prefix\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n直接每个字符串从头开始元素比较，不一样直接return即可A\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string longestCommonPrefix(vector<string>& strs) {\r\n        string str = \"\";\r\n        if (strs.size() == 0) {\r\n            return str;\r\n        }\r\n        char ch;\r\n        int i, j, min = INT_MAX;\r\n        for (int m = 0; m < strs.size(); m++) {\r\n            if (strs[m].size() < min) {\r\n                min = strs[m].size();\r\n            }\r\n        }\r\n        for (i = 0; i < min; i++) {\r\n            ch = strs[0][i];\r\n            for (j = 0; j < strs.size(); j++) {\r\n                if (strs[j][i] != ch) {\r\n                    return str;\r\n                }\r\n            }\r\n            str += ch;\r\n        }\r\n        return str;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "最长公共前缀(字符串)",
        "date": "2020-12-18 17:02:23",
        "tags": [
          "算法",
          "字符串",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(7).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n编写一个函数来查找字符串数组中的最长公共前缀。\r\n\r\n如果不存在公共前缀，返回空字符串 \"\"。\r",
      "fileName": "zui-chang-gong-gong-qian-zhui-zi-fu-chuan"
    },
    {
      "content": "### 题目\r\n写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：\r\nF(0) = 0,   F(1) = 1\r\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.\r\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\r\n<!-- more -->\r\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br><br>\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：n = 2\r\n输出：1<br><br>\r\n示例 2：\r\n\r\n输入：n = 5\r\n输出：5<br><br>\r\n \r\n\r\n提示：\r\n\r\n0 <= n <= 100<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n#### 方法1：递归\r\n常规递归方法，然后愉快的超时\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int fib(int n) {\r\n        if (n == 0) return 0;\r\n        if (n == 1 || n == 2) {\r\n            return 1;\r\n        }\r\n        return fib(n - 1) + fib(n - 2);\r\n    }\r\n};\r\n```\r\n#### 方法2：带备忘录的递归（自顶向下）\r\n可以把递归看成一颗树，自顶向下\r\n在递归的过程中很多元素其实已经被访问过了，比如n = 20，求n = 19 + n = 18，求19的时候求n = 18 + n = 17，这里可以看到n = 18被求了两次，下面的元素还有更多次重复的所以一般的递归时间复杂度非常高。如果可以把每个元素的值记录下来，下次求的时候直接用时间可以减少很多。\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> arr;\r\n\r\n    int help(int n) {\r\n        if (n == 0) return 0;\r\n        if (n == 1 || n == 2) {\r\n            return 1;\r\n        }\r\n        if (arr[n] != 0) { //如果已经记录则直接用\r\n            return arr[n];\r\n        }\r\n        //未记录则记录下来\r\n        arr[n - 1] = help(n - 1) % 1000000007;\r\n        arr[n - 2] = help(n - 2) % 1000000007;\r\n        return arr[n - 1] + arr[n - 2];\r\n    }\r\n\r\n    int fib(int n) {\r\n        for (int i = 1; i <= 101; i++) {\r\n            arr.push_back(0);\r\n        }\r\n        return help(n) % 1000000007;\r\n    }\r\n};\r\n```\r\n#### 方法3：DP（自底向上）\r\n方法2是从树的顶端到下面依次递归求值，也可以从树的底端到顶端求。\r\n还是利用一个数组，把每个值记录下来，从底到顶。\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int fib(int n) {\r\n        int dp[101];\r\n        dp[1] = 1;\r\n        dp[2] = 1;\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n        if (n == 1 || n == 2) {\r\n            return 1;\r\n        }\r\n        for (int i = 3; i <= n; i++) {\r\n            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;\r\n        }\r\n        return dp[n];\r\n    }\r\n};\r\n```",
      "data": {
        "title": "斐波那契数列(递归)",
        "date": "2020-12-17 17:13:05",
        "tags": [
          "算法",
          "递归",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(5).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：\r\nF(0) = 0,   F(1) = 1\r\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.\r\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\r",
      "fileName": "fei-bo-na-qi-shu-lie-di-gui"
    },
    {
      "content": "### 题目\r\n给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。\r\n<!-- more -->\r\n进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？<br><br>\r\n\r\n \r\n\r\n示例 1：\r\n\r\n\r\n输入：root = [1,3,null,null,2]\r\n输出：[3,1,null,null,2]\r\n解释：3 不能是 1 左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。<br><br>\r\n示例 2：\r\n\r\n\r\n输入：root = [3,1,4,null,null,2]\r\n输出：[2,1,4,null,null,3]\r\n解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。<br><br>\r\n \r\n\r\n提示：\r\n\r\n树上节点的数目在范围 [2, 1000] 内\r\n-231 <= Node.val <= 231 - 1<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/recover-binary-search-tree\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n二叉树搜索树中序遍历就是二叉搜索树元素从小到大排列，知道这个就好做了。\r\n采用中序遍历：每个节点和前一个相比，小的话就把前一个节点记录下来(只有第一次记录前一个节点，因为题目说明只有两个元素错位)，然后下一次遇到前一个元素比后面的元素大的情况把后一个元素记录下来。\r\n最后把两个记录点的val交换。\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* pre = new TreeNode(-2147483648);\r\n    TreeNode* s = NULL;\r\n    TreeNode* t = new TreeNode();\r\n\r\n    void recover(TreeNode* root) {\r\n        if (root == NULL) {\r\n            return;\r\n        }\r\n        recover(root->left);\r\n        if (root->val < pre->val) {\r\n            s = (s == NULL) ? pre:s;\r\n            t = root; \r\n        }\r\n        pre = root;\r\n        recover(root->right);\r\n    }\r\n    void recoverTree(TreeNode* root) {\r\n        recover(root);\r\n        int n = s->val;\r\n        s->val = t->val;\r\n        t->val = n;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "恢复二叉搜索树(二叉树)",
        "date": "2020-12-16 19:44:46",
        "tags": [
          "二叉树",
          "算法",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/ycL3yPmxeH.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。\r",
      "fileName": "hui-fu-er-cha-sou-suo-shu-er-cha-shu"
    },
    {
      "content": "### 题目\r\n给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><br>\r\n<!-- more -->\r\n例如：\r\n给定二叉树 [3,9,20,null,null,15,7],\r\n```\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n```\r\n返回锯齿形层次遍历如下：\r\n\r\n[\r\n  [3],\r\n  [20,9],\r\n  [15,7]\r\n]<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n\r\n### 思路\r\n首先把每一行所有节点存放到一个数组中，然后再把这个数组存放到一个二维数组中，然后把一维数组清空。依次遍历，然后每遍历完一行下一行数组翻转即可。\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool jud = false; //判断因子，判断是否翻转\r\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\r\n        vector<vector<int>> arr;\r\n        vector<int> brr;\r\n        if (root == NULL) {\r\n            return arr;\r\n        }\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n        TreeNode* node;\r\n        while (!q.empty()) { //BFS\r\n            int n = q.size(); //记录当前队列元素数量\r\n            for (int i = 0; i < n; i++) {\r\n                brr.push_back(q.front()->val); //把上一层所有节点加入到一维数组中\r\n                node = q.front();\r\n                q.pop();\r\n                if (node->left != NULL) {\r\n                    q.push(node->left);\r\n                }\r\n                if (node->right != NULL) {\r\n                    q.push(node->right);\r\n                }\r\n            }\r\n            if (jud == true) { //翻转\r\n                reverse(brr.begin(), brr.end());\r\n                jud = false; //更改反转因子\r\n            }\r\n            else { //不翻转\r\n                jud = true; //更改反转因子\r\n            }\r\n            arr.push_back(brr); //把一维数组加入到二维数组\r\n            brr.clear(); //然后把一维数组清空\r\n        }\r\n        return arr;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "二叉树的锯齿形层次遍历(二叉树)(BFS)",
        "date": "2020-12-15 17:01:22",
        "tags": [
          "二叉树",
          "LeetCode",
          "算法"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/gridea-zhu-ti-fog-geng-xin-ri-zhi.jpeg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><br>\r",
      "fileName": "er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-er-cha-shu-bfs"
    },
    {
      "content": "### 题目\r\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\r\n<!-- more -->\r\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\r\n\r\n示例: \r\n\r\n你可以将以下二叉树：\r\n```\r\n      1\r\n     / \\\r\n    2   3\r\n       / \\\r\n      4   5\r\n```\r\n序列化为 \"[1,2,3,null,null,4,5]\"\r\n提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\r\n\r\n说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Codec {\r\npublic:\r\n\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n        string str = \"\";\r\n        TreeNode* node;\r\n        while (!q.empty()) {\r\n            int n = q.size();\r\n            for (int i = 0; i < n; i++) {\r\n                node = q.front();\r\n                q.pop();\r\n                if (node == NULL) {\r\n                    str += \"null,\";\r\n                    continue;\r\n                }\r\n                str += to_string(node->val);\r\n                str += \",\";\r\n                q.push(node->left);\r\n                q.push(node->right);\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) {\r\n        if (data[0] == 'n') {\r\n            return NULL;\r\n        }\r\n        int m = 0, n = 0;\r\n        TreeNode* node;\r\n        queue<TreeNode*> q;\r\n        vector<int> arr;\r\n        string str = \"\";\r\n        while (m < data.size()) {\r\n            if (data[m] == ',') {\r\n                if (!str.empty())\r\n                    arr.push_back(stoi(str));\r\n                str = \"\";\r\n                m++;\r\n                continue;\r\n            }\r\n            if (data[m] == 'n') {\r\n                m += 4;\r\n                if (!str.empty())\r\n                    arr.push_back(stoi(str));\r\n                arr.push_back(-1024);\r\n                str = \"\";\r\n                continue;\r\n            }\r\n            str += data[m];\r\n            m++;\r\n        }\r\n        TreeNode* root = new TreeNode(arr[0]);\r\n        if (arr.size() == 1) {\r\n            return root;\r\n        }\r\n        m = 1;\r\n        q.push(root);\r\n        while (!q.empty() && m < arr.size()) {\r\n            n = q.size();\r\n            for (int i = 0; i < n; i++) {\r\n                node = q.front();\r\n                q.pop();\r\n                if (arr[m] != -1024) {\r\n                    node->left = new TreeNode(arr[m]);\r\n                    q.push(node->left);\r\n                }\r\n                else {\r\n                    node->left = nullptr;\r\n                }\r\n                if (arr[m + 1] != -1024) {\r\n                    node->right = new TreeNode(arr[m+1]);\r\n                    q.push(node->right);\r\n                }\r\n                else {\r\n                    node->right = nullptr;\r\n                }\r\n                m += 2;\r\n            }\r\n        }\r\n        return root;\r\n    }\r\n};\r\n\r\n// Your Codec object will be instantiated and called as such:\r\n// Codec ser, deser;\r\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\r\n```",
      "data": {
        "title": "二叉树的序列化与反序列化(二叉树)",
        "date": "2020-12-15 08:23:20",
        "tags": [
          "二叉树",
          "算法",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/yd8kqCqZwg.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\r",
      "fileName": "er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua"
    },
    {
      "content": "### 题目\r\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\r\n<!-- more -->\r\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br><br>\r\n\r\n例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]\r\n\r\n![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)\r\n\r\n \r\n\r\n示例 1:\r\n\r\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\r\n输出: 3\r\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br><br>\r\n示例 2:\r\n\r\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\r\n输出: 5\r\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。<br><br>\r\n \r\n\r\n说明:\r\n\r\n所有节点的值都是唯一的。\r\np、q 为不同节点且均存在于给定的二叉树中。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n\r\n### 思路\r\n递归自底向上遍历每个节点：\r\n如果此节点为空返回空；\r\n如果此节点为p或q返回该节点；\r\n如果该节点的左孩子或右孩子为p或q，返回该节点的左子树或右子树；\r\n如果该节点左子树为p右子树为q则该节点为最近公共祖先，返回该节点。\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\r\n        if (root == NULL || root == p || root == q) {\r\n            return root;\r\n        }\r\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\r\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\r\n        if (left != NULL && right != NULL) {\r\n            return root;\r\n        }\r\n        return left ? left : right;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "二叉树的最近公共祖先(二叉树)",
        "date": "2020-12-14 20:12:36",
        "tags": [
          "二叉树",
          "算法",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(4).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\r",
      "fileName": "er-cha-shu-de-zui-jin-gong-gong-zu-xian-er-cha-shu"
    },
    {
      "content": "### 题目\r\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\r\n<!-- more -->\r\n \r\n\r\n示例 1:\r\n\r\n输入: s = \"abcabcbb\"\r\n输出: 3 \r\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。<br><br>\r\n示例 2:\r\n\r\n输入: s = \"bbbbb\"\r\n输出: 1\r\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。<br><br>\r\n示例 3:\r\n\r\n输入: s = \"pwwkew\"\r\n输出: 3\r\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\r\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。<br><br>\r\n示例 4:\r\n\r\n输入: s = \"\"\r\n输出: 0<br><br>\r\n \r\n\r\n提示：\r\n\r\n0 <= s.length <= 5 * 104\r\ns 由英文字母、数字、符号和空格组成<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n\r\n### 思路\r\n定义p为子串的头，j为尾部，p到j为一个窗口，如果新的元素i和窗口里的元素相同，则把p移动到i的后面。记录每一个窗口的长度，最后取最大\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s)\r\n    {\r\n        if (s.size() == 0)\r\n        {\r\n            return 0;\r\n        }\r\n        int i, j, max, n, p, jud = 0;\r\n        i = 0;\r\n        p = i;\r\n        j = i + 1;\r\n        max = 1;\r\n        n = 1;\r\n        for (; j < s.size(); j++)\r\n        {\r\n            jud = 0;\r\n            for (p = i; p < j; p++)\r\n            {\r\n                if (s[p] == s[j])\r\n                {\r\n                    i = p + 1;\r\n                    if (i == j)\r\n                    {\r\n                        n = 1;\r\n                    }\r\n                    else if (s[i] == s[j])\r\n                    {\r\n                        n = j - i;\r\n                    }\r\n                    else\r\n                    {\r\n                        n = j - i + 1;\r\n                    }\r\n                    jud = 1;\r\n                    break;\r\n                }\r\n            }\r\n            if (jud == 1)\r\n            {\r\n                continue;\r\n            }\r\n            n++;\r\n            if (n > max)\r\n                max = n;\r\n        }\r\n        return max;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "无重复字符的最长子串(滑动窗口)",
        "date": "2020-12-13 17:21:43",
        "tags": [
          "算法",
          "LeetCode",
          "滑动窗口"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/54lqq0%20(1).jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\r",
      "fileName": "wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-hua-dong-chuang-kou"
    },
    {
      "content": "### 题目\r\n给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\r\n<!-- more -->\r\nstruct Node {\r\n  int val;\r\n  Node *left;\r\n  Node *right;\r\n  Node *next;\r\n}\r\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\r\n\r\n初始状态下，所有 next 指针都被设置为 NULL。<br><br>\r\n\r\n \r\n\r\n进阶：\r\n\r\n你只能使用常量级额外空间。\r\n使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br><br>\r\n\r\n输入：root = [1,2,3,4,5,6,7]\r\n输出：[1,#,2,3,#,4,5,6,7,#]\r\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。<br><br>\r\n \r\n\r\n提示：\r\n\r\n树中节点的数量少于 4096\r\n-1000 <= node.val <= 1000<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n\r\n### 思路\r\n每次循环用队列存储每一行的节点，每存储一个节点让前一个节点指向现在的节点。\r\n每次循环队列弹一个，进两个。这样每次循环完队列把上一层的节点全部弹出，把新一层的节点全部加入。\r\n```C++\r\n/*\r\n// Definition for a Node.\r\nclass Node {\r\npublic:\r\n    int val;\r\n    Node* left;\r\n    Node* right;\r\n    Node* next;\r\n\r\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\r\n\r\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\r\n\r\n    Node(int _val, Node* _left, Node* _right, Node* _next)\r\n        : val(_val), left(_left), right(_right), next(_next) {}\r\n};\r\n*/\r\n\r\nclass Solution {\r\npublic:\r\n    Node* connect(Node* root) {\r\n        if (root == NULL) {\r\n            return NULL;\r\n        }\r\n        int num = 0;\r\n        queue<Node*> q;\r\n        q.push(root);\r\n        while (!q.empty()) {\r\n            Node* node;\r\n            Node* front;\r\n            front = NULL;\r\n            num = q.size();\r\n            for (int j = 0; j < num; j++) {\r\n                node = q.front();\r\n                q.pop();\r\n                if (node->left != NULL)\r\n                    q.push(node->left);\r\n                if (node->right != NULL) \r\n                    q.push(node->right);\r\n                if (front == NULL) {\r\n                    front = node;\r\n                }\r\n                else {\r\n                    front->next = node;\r\n                    front = front->next;\r\n                }\r\n            };\r\n        }\r\n        return root;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "填充每个节点的下一个右侧节点指针(二叉树)(BFS)",
        "date": "2020-12-13 17:10:23",
        "tags": [
          "二叉树",
          "算法",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/CV9awWXoCq.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\r",
      "fileName": "tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-er-cha-shu-bfs"
    },
    {
      "content": "### 题目\r\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\r\n<!-- more -->\r\n说明: 叶子节点是指没有子节点的节点。<br><br>\r\n\r\n示例: \r\n给定如下二叉树，以及目标和 sum = 22，\r\n返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/path-sum\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n### 思路\r\n从根节点开始遍历每个节点，每次递归将此根节点和前面路径的节点传入，然后当时叶子结点时判断总路径是否相等。\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool jud = false; //判断因子\r\n    int num;\r\n    void path(TreeNode* root, int n) {\r\n        if (root == NULL) { //根为空的情况\r\n            return;\r\n        }\r\n        //判断路径和是否相等，并且判断是否为叶子结点\r\n        if (root->val + n == num && root->left == NULL && root->right == NULL) { \r\n            jud = true;\r\n            return;\r\n        }\r\n        //递归遍历每个节点\r\n        path(root->left, root->val + n);\r\n        path(root->right, root->val + n);\r\n    }\r\n    bool hasPathSum(TreeNode* root, int sum) {\r\n        //判断两者中特殊情况\r\n        if (root == NULL && sum == 0) {\r\n            return false;\r\n        }\r\n        if (root == NULL && sum != 0) {\r\n            return false;\r\n        }\r\n        num = sum;\r\n        path(root, 0);\r\n        return jud;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "路径总和(二叉树)(DFS)",
        "date": "2020-12-13 15:52:49",
        "tags": [
          "二叉树",
          "算法",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/Dl0g4BB4Fp.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\r",
      "fileName": "lu-jing-zong-he-er-cha-shu-dfs"
    },
    {
      "content": "### 题目\r\n给定一个二叉树，找出其最小深度。\r\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\r\n说明：叶子节点是指没有子节点的节点。\r\n<!-- more -->\r\n \r\n\r\n示例 1：\r\n输入：root = [3,9,20,null,null,15,7]\r\n输出：2<br><br>\r\n\r\n示例 2：\r\n输入：root = [2,null,3,null,4,null,5,null,6]\r\n输出：5<br><br>\r\n\r\n提示：\r\n树中节点数的范围在 [0, 105] 内\r\n-1000 <= Node.val <= 1000<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n二叉树每个节点的路径最小(最大)为左子树和右子树中最小(最大)路径加上它自己\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int minDepth(TreeNode* root) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        int left = minDepth(root->left);\r\n        int right = minDepth(root->right);\r\n        if (left == 0) {\r\n            return right + 1;\r\n        }\r\n        if (right == 0) {\r\n            return left + 1;\r\n        }\r\n        return min(left, right) + 1;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "二叉树的最小(最大)路径(二叉树)",
        "date": "2020-12-13 13:54:14",
        "tags": [
          "二叉树",
          "LeetCode",
          "算法"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(8).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个二叉树，找出其最小深度。\r\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\r\n说明：叶子节点是指没有子节点的节点。\r",
      "fileName": "er-cha-shu-de-zui-xiao-zui-da-lu-jing-er-cha-shu"
    },
    {
      "content": "### 题目\r\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\r\n<!-- more -->\r\n \r\n\r\n示例：\r\n二叉树：[3,9,20,null,null,15,7],\r\n![](https://sakuratears.cn/post-images/1607763983990.png)\r\n\r\n返回其层次遍历结果：\r\n\r\n[\r\n  [3],\r\n  [9,20],\r\n  [15,7]\r\n]<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 解题思路\r\n在用BFS循环遍历时。先记录现在队列里面的元素个数n，n就是此二叉树这一深度拥有的节点数，然后循环n次，把n个节点的左右孩子都添加到队列里面，每次循环完把队列前面的元素pop到一个动态数组里，这样就能实现一个深度的节点为一个数组了\r\n\r\n### 代码\r\n\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> arr;\r\n\r\n    void BFS(TreeNode* root) {\r\n        queue<TreeNode*> brr;\r\n        vector<int> crr;\r\n        brr.push(root);\r\n        int n = 0;\r\n        while (!brr.empty()) {\r\n            TreeNode* node = brr.front();\r\n            n = brr.size(); //n记录当前队列元素个数\r\n            for (int i = 0; i < n; i++) { //循环n次\r\n                if (node->left != NULL) { //左孩子不为空则添加左孩子\r\n                    brr.push(node->left);\r\n                }\r\n                if (node->right != NULL) { //右孩子不为空则添加右孩子\r\n                    brr.push(node->right);\r\n                }\r\n                crr.push_back(brr.front()->val); //每次循环把队列的头元素的值添加到一个数组里\r\n                brr.pop();\r\n                node = brr.front(); //节点移动到下一个\r\n            }\r\n            arr.push_back(crr); //把当前数组元素添加到二维数组中\r\n            crr.clear(); //当前数组清空\r\n        }\r\n    }\r\n\r\n    vector<vector<int>> levelOrder(TreeNode* root) {\r\n        if (root == NULL) {\r\n            return arr;\r\n        }\r\n        BFS(root);\r\n        return arr;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "二叉树的层序遍历(二叉树)(BFS)",
        "date": "2020-12-12 16:51:11",
        "tags": [
          "二叉树",
          "LeetCode",
          "算法"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/ycL3yPmxeH.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\r",
      "fileName": "er-cha-shu-de-ceng-xu-bian-li-er-cha-shu-bfs"
    },
    {
      "content": "### 题目\r\n根据一棵树的前序遍历与中序遍历构造二叉树。\r\n<!-- more -->\r\n注意:\r\n你可以假设树中没有重复的元素。\r\n\r\n例如，给出\r\n\r\n前序遍历 preorder = [3,9,20,15,7]\r\n中序遍历 inorder = [9,3,15,20,7]\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n和上一题基本一样0.0\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder) {\r\n        TreeNode* tree = new TreeNode(preorder[0]);\r\n        if (inorder.size() <= 1) {\r\n            return tree;\r\n        }\r\n        int i, m;\r\n        for (i = 0; i < inorder.size(); i++) {\r\n            if (inorder[i] == preorder[0]) {\r\n                break;\r\n            }\r\n        }\r\n        m = i;\r\n        vector<int> arr0, arr1, brr0, brr1;\r\n        if (m == 0) {\r\n            tree->left = NULL;\r\n        }\r\n        else {\r\n            for (int j = 0, i = 1; j < m; j++, i++) {\r\n                arr0.push_back(preorder[i]);\r\n                brr0.push_back(inorder[j]);\r\n            }\r\n            tree->left = build(arr0, brr0);\r\n        }\r\n        if (m >= inorder.size() - 1) {\r\n            tree->right = NULL;\r\n        }\r\n        else {\r\n            for (int j = m + 1; j < inorder.size(); j++) {\r\n                arr1.push_back(preorder[j]);\r\n                brr1.push_back(inorder[j]);\r\n            }\r\n            tree->right = build(arr1, brr1);\r\n        }\r\n        return tree;\r\n    }\r\n\r\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\r\n        if (inorder.size() == 0 || preorder.size() == 0) {\r\n            return NULL;\r\n        }\r\n        return build(preorder, inorder);\r\n    }\r\n};\r\n```",
      "data": {
        "title": "从前序与中序遍历序列构造二叉树(二叉树)",
        "date": "2020-12-12 12:26:26",
        "tags": [
          "二叉树",
          "算法",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/PzudLoS8IG.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n根据一棵树的前序遍历与中序遍历构造二叉树。\r",
      "fileName": "cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu"
    },
    {
      "content": "### 题目\r\n根据一棵树的中序遍历与后序遍历构造二叉树。\r\n<!-- more -->\r\n注意:\r\n你可以假设树中没有重复的元素。<br><br>\r\n\r\n例如，给出\r\n中序遍历 inorder = [9,3,15,20,7]\r\n后序遍历 postorder = [9,15,7,20,3]<br><br>\r\n\r\n得到结果：[3,9,20,null,null,15,7]<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n\r\n### 思路\r\n二叉树的后序遍历最后一个元素是二叉树的的根节点，然后中序遍历根节点左边元素是左子树的节点，右边是右子树的节点。\r\n知道这个这道题就很简单了，用递归调用求左子树右子树。\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* build(vector<int>& inorder, vector<int>& postorder) {\r\n        TreeNode* tree = new TreeNode(postorder[postorder.size() - 1]);\r\n        if (inorder.size() <= 1) {\r\n            return tree;\r\n        }\r\n        int i, m; //找到根节点m\r\n        for (i = 0; i < inorder.size(); i++) {\r\n            if (inorder[i] == postorder[postorder.size() - 1]) {\r\n                break;\r\n            }\r\n        }\r\n        m = i;\r\n        vector<int> arr0, arr1, brr0, brr1;\r\n        if (m == 0) { //考虑左边已经空了的情况\r\n            tree->left = NULL;\r\n        }\r\n        else {\r\n            for (int i = 0; i < m; i++) {\r\n                arr0.push_back(inorder[i]);\r\n                brr0.push_back(postorder[i]);\r\n            }\r\n            tree->left = build(arr0, brr0);\r\n        }\r\n        if (m >= inorder.size() - 1) {  //考虑右边已经空了的情况\r\n            tree->right = NULL;\r\n        }\r\n        else {\r\n            for (int i = m + 1, j = m; i < inorder.size(); i++, j++) {\r\n                arr1.push_back(inorder[i]);\r\n                brr1.push_back(postorder[j]);\r\n            }\r\n            tree->right = build(arr1, brr1);\r\n        }\r\n        return tree;\r\n    }\r\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\r\n        if (inorder.size() == 0 || postorder.size() == 0) {\r\n            return NULL;\r\n        }\r\n        return build(inorder, postorder);\r\n    }\r\n};\r\n```",
      "data": {
        "title": "从中序与后序遍历序列构造二叉树(二叉树)",
        "date": "2020-12-11 20:51:54",
        "tags": [
          "算法",
          "二叉树",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/gridea-zhu-ti-fog-geng-xin-ri-zhi.jpeg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n根据一棵树的中序遍历与后序遍历构造二叉树。\r",
      "fileName": "cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu"
    },
    {
      "content": "### 题目\r\n给定一个二叉树的根节点 root ，返回它的 中序 遍历。\r\n<!-- more -->\r\n \r\n\r\n示例 1：\r\n\r\n\r\n输入：root = [1,null,2,3]\r\n输出：[1,3,2]<br><br>\r\n示例 2：\r\n\r\n输入：root = []\r\n输出：[]<br><br>\r\n示例 3：\r\n\r\n输入：root = [1]\r\n输出：[1]<br><br>\r\n示例 4：\r\n\r\n\r\n输入：root = [1,2]\r\n输出：[2,1]<br><br>\r\n示例 5：\r\n\r\n\r\n输入：root = [1,null,2]\r\n输出：[1,2]<br><br>\r\n \r\n\r\n提示：\r\n\r\n树中节点数目在范围 [0, 100] 内\r\n-100 <= Node.val <= 100<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n就二叉树的中序遍历，没有任何坑，直接写就行\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    vector<int> arr;\r\n    void traversal(TreeNode* root) {\r\n        if (root == NULL) {\r\n            return;\r\n        }\r\n        inorderTraversal(root->left);\r\n        arr.push_back(root->val);\r\n        inorderTraversal(root->right);\r\n    }\r\n    vector<int> inorderTraversal(TreeNode* root) {\r\n        traversal(root);\r\n        return arr;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "二叉树的中序遍历(二叉树)",
        "date": "2020-12-10 17:26:48",
        "tags": [
          "算法",
          "二叉树",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(3).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个二叉树的根节点 root ，返回它的 中序 遍历。\r",
      "fileName": "er-cha-shu-de-zhong-xu-bian-li"
    },
    {
      "content": "### 题目\r\n给定一个二叉树，检查它是否是镜像对称的。\r\n<!-- more -->\r\n\r\n\r\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\r\n\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_35r5gAjUVn.png)\r\n\r\n\r\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\r\n\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_BIOlXHyv1p.png)\r\n\r\n\r\n进阶：\r\n\r\n你可以运用递归和迭代两种方法解决这个问题吗？<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/symmetric-tree\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n\r\n### 思路\r\n判断二叉树是否对称可以理解为判断一个节点的两个子树的里侧和外侧是否对称，就是后序遍历。\r\n判断外侧是否对称，传入左节点的左孩子，右节点的右孩子。\r\n判断里侧是否对称，传入左节点的右孩子，右节点的左孩子。\r\n可以用递归挨个判断，所以递归函数传的值就要是left,right两个，想通这一点就好做了。\r\n判断空的情况，\r\n左空右空       返回true\r\n左空右不空    返回false\r\n左不空右空    返回false\r\n最后是都不空，判断值\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool cmp(TreeNode* left, TreeNode* right) {\r\n        if (left == NULL && right == NULL) {\r\n            return true;\r\n        }\r\n        else if (left == NULL && right != NULL) {\r\n            return false;\r\n        }\r\n        else if (left != NULL && right == NULL) {\r\n            return false;\r\n        }\r\n        //都不空判断值\r\n        else if (left->val != right->val) {\r\n            return false;\r\n        }\r\n\r\n        bool in = cmp(left->right, right->left);\r\n        bool out = cmp(left->left, right->right);\r\n        return in && out;\r\n    }\r\n    bool isSymmetric(TreeNode* root) {\r\n        if (root == NULL) {\r\n            return true;\r\n        }\r\n        return cmp(root->left, root->right);\r\n    }\r\n};\r\n```",
      "data": {
        "title": "对称二叉树(二叉树)",
        "date": "2020-12-10 14:44:24",
        "tags": [
          "算法",
          "LeetCode",
          "二叉树"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(1).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个二叉树，检查它是否是镜像对称的。\r",
      "fileName": "dui-cheng-er-cha-shu"
    },
    {
      "content": "### 题目\r\n给定一个二叉树，判断它是否是高度平衡的二叉树。<br><br>\r\n<!-- more -->\r\n本题中，一棵高度平衡二叉树定义为：\r\n\r\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。<br><br>\r\n\r\n \r\n\r\n示例 1：\r\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\r\n\r\n输入：root = [3,9,20,null,null,15,7]\r\n输出：true<br><br>\r\n示例 2：\r\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\r\n\r\n输入：root = [1,2,2,3,3,null,null,4,4]\r\n输出：false<br><br>\r\n示例 3：\r\n\r\n输入：root = []\r\n输出：true<br><br>\r\n \r\n\r\n提示：\r\n\r\n树中的节点数在范围 [0, 5000] 内\r\n-104 <= Node.val <= 104<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/balanced-binary-tree\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n\r\n### 思路\r\n还是用二叉树的框架就行，每个节点的最大深度就是左子树或右子树中的最大深度加1\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool jud = true; //判断因子\r\n    int deep(TreeNode* root) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        int left = deep(root->left);\r\n        int right = deep(root->right);\r\n        if (abs(left - right) > 1) { //如果左右子树深度相差大于1将判断因子设为false;\r\n            jud = false;\r\n        }\r\n        return max(left, right) + 1;\r\n    }\r\n    bool isBalanced(TreeNode* root) {\r\n        if (root == nullptr) {\r\n            return true;\r\n        }\r\n        deep(root);\r\n        return jud;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "平衡二叉树(二叉树)",
        "date": "2020-12-09 10:40:35",
        "tags": [
          "算法",
          "二叉树",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/54lqq0%20(1).jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个二叉树，判断它是否是高度平衡的二叉树。<br><br>\r",
      "fileName": "ping-heng-er-cha-shu-er-cha-shu"
    },
    {
      "content": "### 题目\r\n给定一个非空二叉树，返回其最大路径和。<br><br>\r\n<!-- more -->\r\n本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。<br><br>\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：[1,2,3]\r\n\r\n       1\r\n      / \\\r\n     2   3\r\n\r\n输出：6<br><br>\r\n示例 2：\r\n\r\n输入：[-10,9,20,null,null,15,7]\r\n\r\n   -10\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n输出：42<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n每一个节点的最大路径是它左右子树中最大的路径加上它自己，这样就是先遍历左子树，再遍历右子树。\r\n这样就是树的后序遍历+DFS的思想。\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int imax = INT_MIN;\r\n    int maxpath(TreeNode* root) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n\r\n        int left = max(0, maxpath(root->left));\r\n        int right = max(0, maxpath(root->right));\r\n        /*二叉树的后序遍历*/\r\n        imax = max(imax, left + right + root->val);\r\n        return max(left, right) + root->val;\r\n    }\r\n    int maxPathSum(TreeNode* root) {\r\n        maxpath(root);\r\n        return imax;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "二叉树中的最大路径和(二叉树)(DFS)",
        "date": "2020-12-08 21:18:54",
        "tags": [
          "算法",
          "LeetCode",
          "二叉树",
          "搜索"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(4).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个非空二叉树，返回其最大路径和。<br><br>\r",
      "fileName": "er-cha-shu-zhong-de-zui-da-lu-jing-he-er-cha-shu"
    },
    {
      "content": "### 题目\r\n给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><br>\r\n<!-- more -->\r\n在杨辉三角中，每个数是它左上方和右上方的数的和。<br><br>\r\n\r\n示例:<br><br>\r\n\r\n输入: 5\r\n输出:\r\n[\r\n     [1],\r\n    [1,1],\r\n   [1,2,1],\r\n  [1,3,3,1],\r\n [1,4,6,4,1]\r\n]<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/pascals-triangle\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n\r\n### 思路\r\n简单题，直接写就行，leetcode的测试用例也没啥恶心的~~可能是这个题没法恶心了吧~~\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> generate(int numRows) {\r\n        vector<vector<int>> nums;\r\n        if (numRows == 0) {  //判断0的情况下\r\n            return nums;\r\n        }\r\n        vector<int> num;\r\n        num.push_back(1);\r\n        nums.push_back(num);\r\n        for (int i = 1; i < numRows; i++) {\r\n            vector<int> num;\r\n            num.push_back(1);\r\n            for (int j = 1; j < i; j++) {\r\n                num.push_back(nums[i - 1][j - 1] + nums[i - 1][j]); //每行数组的[j]是上一个数组的[j]位置+[j - 1]位置\r\n            }\r\n            num.push_back(1);\r\n            nums.push_back(num);\r\n        }\r\n        return nums;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "杨辉三角(数组)",
        "date": "2020-12-07 17:18:43",
        "tags": [
          "算法",
          "LeetCode",
          "数组"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(5).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><br>\r",
      "fileName": "yang-hui-san-jiao"
    },
    {
      "content": "### 题目\r\n请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br><br>\r\n<!-- more -->\r\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br><br>\r\n\r\n如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。\r\n假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。\r\n该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。\r\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br><br>\r\n\r\n在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br><br>\r\n\r\n提示：<br><br>\r\n\r\n本题中的空白字符只包括空格字符 ' ' 。\r\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。<br><br>\r\n \r\n\r\n示例 1:\r\n\r\n输入: \"42\"\r\n输出: 42<br><br>\r\n示例 2:\r\n\r\n输入: \"   -42\"\r\n输出: -42\r\n解释: 第一个非空白字符为 '-', 它是一个负号。\r\n     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br><br>\r\n示例 3:\r\n\r\n输入: \"4193 with words\"\r\n输出: 4193\r\n解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。<br><br>\r\n示例 4:\r\n\r\n输入: \"words and 987\"\r\n输出: 0\r\n解释: 第一个非空字符是 'w', 但它不是数字或正、负号。\r\n     因此无法执行有效的转换。<br><br>\r\n示例 5:\r\n\r\n输入: \"-91283472332\"\r\n输出: -2147483648\r\n解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 \r\n     因此返回 INT_MIN (−231) 。<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/string-to-integer-atoi\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n\r\n### 思路\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int myAtoi(string s) {\r\n        int i = 0, m = 0, jud = 0, n = 0, p, j = 0;\r\n        while (s[i] == ' ') {\r\n            i++;\r\n        }\r\n        if (s[i] != '-' && s[i] != '+' && (s[i] > 57 || s[i] < 48))\r\n            return 0;\r\n        if ((s[i] == '-' || s[i] == '+') && (s[i + 1] > 57 || s[i + 1] < 48))\r\n            return 0;\r\n        while (s[i] > 57 || s[i] < 48) {\r\n            i++;\r\n        }\r\n        if (i > 0 && s[i - 1] == '-') {\r\n            jud = 1;\r\n        }\r\n        while (s[i] == '0') {\r\n            i++;\r\n        }\r\n        if (s[i] > 57 || s[i] < 48) {\r\n            return 0;\r\n        }\r\n        j = i;\r\n        while (s[i] <= 57 && s[i] >= 48) {\r\n            i++;\r\n            n++;//位数\r\n        }\r\n        if (n > 10) {\r\n            if (jud == 0)\r\n                return pow(2, 31) - 1;\r\n            else\r\n                return -pow(2, 31);\r\n        }\r\n        p = n - 1;\r\n        for (; j < i; j++) {\r\n            if ((m + (s[j] - 48) * pow(10, p) > pow(2, 31) - 1) && jud == 0) {\r\n                return pow(2, 31) - 1;\r\n            }\r\n            if ((m + (s[j] - 48) * pow(10, p) >= pow(2, 31)) && jud == 1) {\r\n                return -pow(2, 31);\r\n            }\r\n            m += (s[j] - 48) * pow(10, p);\r\n            p--;\r\n        }\r\n        if (jud == 1) {\r\n            m = -m;\r\n        }\r\n        return m;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "字符串转换整数 (atoi)(字符串)",
        "date": "2020-12-06 23:19:12",
        "tags": [
          "算法",
          "LeetCode",
          "字符串"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(9).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br><br>\r",
      "fileName": "zi-fu-chuan-zhuan-huan-zheng-shu-atoi"
    },
    {
      "content": "### 题目\r\n给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br><br>\r\n<!-- more -->\r\n示例 1:\r\n\r\n输入: 123\r\n输出: 321<br><br>\r\n\r\n 示例 2:\r\n\r\n输入: -123\r\n输出: -321<br><br>\r\n\r\n示例 3:\r\n\r\n输入: 120\r\n输出: 21<br><br>\r\n\r\n注意:<br><br>\r\n\r\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/reverse-integer\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\r\n\r\n### 题解\r\n多注意爆int的地方，多wa几发就过了~~手动狗头~~\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int reverse(int x) {\r\n        int j = 0, m = 0, num = 0, jud = 0;\r\n        char str[1000];\r\n        int i = 0;\r\n        if (x < 0)\r\n        {\r\n            if (x <= -pow(2, 31)) // 负数正好没爆int，转正可能就会正好爆\r\n                return 0;\r\n            x = -x;\r\n            jud = 1;\r\n        }\r\n        while (x > 0)\r\n        {\r\n            str[i++] = x % 10 + 48;\r\n            x /= 10;\r\n        }\r\n        str[i] = '\\0';\r\n        if (str[0] == '0')\r\n        {\r\n            m = 1;\r\n        }\r\n        for (int i = m; str[i] != '\\0'; i++)\r\n        {\r\n            j++;\r\n        }\r\n        j--;\r\n        for (int i = m; str[i] != '\\0'; i++)\r\n        {\r\n            if ((str[i] - 48) * pow(10, j) > pow(2, 31) - 1 || (str[i] - 48) * pow(10, j) < -pow(2, 31)) { //可能爆int的地方\r\n                return 0;\r\n            }\r\n            if (num + (str[i] - 48) * pow(10, j) > pow(2, 31) - 1 || num + (str[i] - 48) * pow(10, j) < -pow(2, 31)) {  //可能爆int的地方\r\n                return 0;\r\n            }\r\n            num += (str[i] - 48) * pow(10, j);\r\n            j--;\r\n        }\r\n        if (jud != 0)\r\n        {\r\n            num = -num;\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```",
      "data": {
        "title": "整数反转(数组)",
        "date": "2020-12-06 17:16:41",
        "tags": [
          "算法",
          "LeetCode",
          "数组"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(7).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br><br>\r",
      "fileName": "zheng-shu-fan-zhuan"
    },
    {
      "content": "### 题目\r\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>\r\n<!-- more -->\r\n比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下：<br>\r\n\r\nL   C   I   R\r\nE T O E S I I G\r\nE   D   H   N\r\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。<br>\r\n\r\n请你实现这个将字符串进行指定行数变换的函数：<br>\r\n\r\nstring convert(string s, int numRows);<br>\r\n\r\n示例 1:\r\n输入: s = \"LEETCODEISHIRING\", numRows = 3\r\n输出: \"LCIRETOESIIGEDHN\"<br>\r\n\r\n示例 2:\r\n输入: s = \"LEETCODEISHIRING\", numRows = 4\r\n输出: \"LDREOEIIECIHNTSG\"\r\n解释:<br>\r\n\r\nL     D     R\r\nE   O E   I I\r\nE C   I H   N\r\nT     S     G<br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/zigzag-conversion\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>\r\n\r\n### 思路\r\n#### 代码1.\r\n纯暴力写出来了，贴个代码算了0.0\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string convert(string s, int numRows)\r\n    {\r\n        if (numRows == 1)\r\n            return s;\r\n        int num = 0, m = 0, p = 1, j = 0;\r\n        char arr[1000][1000];\r\n        string str;\r\n        for (int i = 0; i < 1000; i++)\r\n        {\r\n            for (int j = 0; j < 1000; j++)\r\n            {\r\n                arr[i][j] = NULL;\r\n            }\r\n        }\r\n        for (int i = 0; num < s.size(); i++)\r\n        {\r\n            for (j = 0; j < numRows && num < s.size(); j++)\r\n            {\r\n                if (i == 0 || i == m + numRows - 1)\r\n                {\r\n                    m = i;\r\n                    for (j = 0; j < numRows && num < s.size(); j++)\r\n                    {\r\n                        arr[j][i] = s[num];\r\n                        num++;\r\n                    }\r\n                    p = 0;\r\n                    continue;\r\n                }\r\n                else\r\n                {\r\n                    if (j != numRows - 1 && arr[j + 1][i - 1] != NULL)\r\n                    {\r\n                        if (i != m + 1 && i != 1)\r\n                        {\r\n                            arr[j][i] = s[num];\r\n                            p = 0;\r\n                            num++;\r\n                            continue;\r\n                        }\r\n                        else\r\n                        {\r\n                            j = numRows - 2;\r\n                            arr[j][i] = s[num];\r\n                            i++;\r\n                            j = -1;\r\n                            num++;\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (int i = 0; i < s.size() && str.size() != s.size(); i++)\r\n        {\r\n            for (int j = 0; j < s.size() && str.size() != s.size(); j++)\r\n            {\r\n                if (arr[i][j] >= 41 && arr[i][j] <= 176)\r\n                {\r\n                    str += arr[i][j];\r\n                }\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n};\r\n```\r\n\r\n#### 代码2\r\n1.res[i] += c： 把每个字符 c 填入对应行 s i;\r\n2.i += flag： 更新当前字符 c 对应的行索引；\r\n3.flag = - flag： 在达到 Z 字形转折点时，执行反向<br>\r\n\r\n把每一行放到一个字符串数组里面，利用flag就行上下控制。~~比我那菜鸡算法好太多了~~\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string convert(string s, int numRows)\r\n    {\r\n        if (numRows == 1) {\r\n            return s;\r\n        }\r\n        string str[1000];\r\n        int i = 0, flag = 1, num = 0;\r\n        while (num < s.size())\r\n        {\r\n\r\n            str[i] += s[num];\r\n            i += flag;\r\n            if (i >= numRows)\r\n            {\r\n                flag = -flag;\r\n                i += flag;\r\n                i += flag;\r\n            }\r\n            if (i < 0)\r\n            {\r\n                flag = -flag;\r\n                i += flag;\r\n                i += flag;\r\n            }\r\n            num++;\r\n        }\r\n        s = \"\";\r\n        for (i = 0; i < numRows; i++) {\r\n            s += str[i];\r\n        }\r\n        return s;\r\n    }\r\n};\r\n```\r\n\r\n\r\n",
      "data": {
        "title": "Z 字形变换(字符串)",
        "date": "2020-12-05 20:51:16",
        "tags": [
          "LeetCode",
          "算法",
          "字符串"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(1).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\r\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>\r",
      "fileName": "z-zi-xing-bian-huan"
    },
    {
      "content": "### 题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br><br>\n<!-- more -->\n示例 1：\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。<br><br>\n\n示例 2：\n输入: \"cbbd\"\n输出: \"bb\"<br><br>\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\n\n\n### 题解\n#### 暴力求解\n把每个长度大于二的子串都进行验证，然后取最大，时间复杂度O(n3)，然后就愉快的超时0.0\n```C++\nclass Solution {\npublic:\n    bool vali(string s, int i, int j)\n    {\n        while (i <= j) {\n            if (s[i] != s[j])\n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n    string longestPalindrome(string s) {\n        int size = s.size();\n        if (size < 2)\n            return s;\n        int max = 1;\n        string str = s.substr(0, 1);\n        for (int i = 0; i < size - 1; i++) {\n            for (int j = i + 1; j < size; j++) {\n                if (j - i + 1 > max && vali(s, i, j)) {\n                    max = j - i + 1;\n                    str = s.substr(i, max);\n                }\n            }\n        }\n        return str;\n    }\n};\n```\n\n#### 动态规划\n动态规划关键步骤状态转移：\n一个回文去掉两头以后，剩下的部分依然是回文；\n如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；\n如果一个字符串的头尾两个字符相等，才有必要继续判断下去。\n如果里面的子串是回文，整体就是回文串；\n如果里面的子串不是回文串，整体就不是回文串。<br><br>\n\n定义dp[i][j]表示s[i....j]是否为回文串(左闭右闭)，根据“如果里面的子串判断是否回文”，可以得到转移方程：dp[i][j] = (s[i] == s[j]) && dp[i + 1][j - 1] == true<br><br>\n\n然后考虑一下边界问题：<br><br>\ns[i + 1......j - 1]，成立的条件为长度小于2，即j - 1 - (i + 1) < 2，即j - i < 3.\nj - i < 3 等价于 j - i + 1 < 4，即当子串 s[i..j] 的长度等于 2 或者等于 3 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。<br><br>\n\n如果子串 s[i + 1..j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 1 个字符，显然是回文；\n如果子串 s[i + 1..j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。<br><br>\n\n因此，在 s[i] == s[j] 成立和 j - i < 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。<br><br>\n\n```C++\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int len = s.size();\n        if (len < 2)\n            return s;\n        int begin = 0;\n        int max = 1; //记录回文子串开始位置和长度\n        bool dp[len][len];\n        for (int i = 0; i < len; i++) {\n            dp[i][i] = true; //初始化，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true \n        }\n        for (int j = 1; j < len; j++) {\n            for (int i = 0; i < j; i++) {\n                if (s[i] != s[j]) {\n                    dp[i][j] = false;\n                }\n                else {\n                    if (j - i < 3) {\n                        dp[i][j] = true;\n                    }\n                    else {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n                if (dp[i][j] && j - i + 1 > max) {\n                    begin = i;\n                    max = j - i + 1;\n                }\n            }\n        }\n        string str = \"\";\n        for (int i = begin; i < begin + max; i++) {\n            str += s[i];\n        }\n        return str;\n    }\n};\n```\n\n思路参考：liweiwei1419",
      "data": {
        "title": "最长回文子串(动态规划)",
        "date": "2020-12-04 19:47:51",
        "tags": [
          "算法",
          "LeetCode",
          "动态规划"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(3).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "### 题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br><br>",
      "fileName": "zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua"
    },
    {
      "content": "力扣的困难题~~极其简单！！！~~\n<!-- more -->\n### 题目\n给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br><br>\n\n进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？<br><br>\n\n示例 1：\n输入：nums1 = [1,3], nums2 = [2]\n输出：2.00000\n解释：合并数组 = [1,2,3] ，中位数 2<br><br>\n\n示例 2：\n输入：nums1 = [1,2], nums2 = [3,4]\n输出：2.50000\n解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br><br>\n\n示例 3：\n输入：nums1 = [0,0], nums2 = [0,0]\n输出：0.00000<br><br>\n\n示例 4：\n输入：nums1 = [], nums2 = [1]\n输出：1.00000<br><br>\n\n示例 5：\n输入：nums1 = [2], nums2 = []\n输出：2.00000<br><br>\n \n\n提示：<br><br>\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106<br><br>\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\n\n### 思路\n题目过于简单，把小的数组加到大的数组题然后sort，再找中位数。0.0<br><br>\n\n### 代码\n```C++\nclass Solution {\npublic:\n    double median(vector<int> nums) {\n        if (nums.size() % 2 == 0) {\n            double dou0 = nums[nums.size() / 2];\n            double dou1 = nums[nums.size() / 2 - 1];\n            return (dou0 + dou1) / 2;\n        }\n        else {\n            double dou0 = nums[nums.size() / 2];\n            return dou0;\n        }\n    } \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() == 0 && nums2.size() == 0)\n            return 0;\n        if (nums1.size() >= nums2.size()) {\n            for (int i = 0; i < nums2.size(); i++) {\n                nums1.push_back(nums2[i]);\n            }\n            sort(nums1.begin(), nums1.end());\n            return median(nums1);\n        }\n        else {\n            for (int i = 0; i < nums1.size(); i++) {\n                nums2.push_back(nums1[i]);\n            }\n            sort(nums2.begin(), nums2.end());\n            return median(nums2);\n        }\n    }\n};\n```",
      "data": {
        "title": "寻找两个正序数组的中位数(分治)",
        "date": "2020-12-04 14:42:22",
        "tags": [
          "算法",
          "分治",
          "LeetCode"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/gridea-zhu-ti-fog-geng-xin-ri-zhi.jpeg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "力扣的困难题~~极其简单！！！~~",
      "fileName": "xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu-fen-zhi"
    },
    {
      "content": "LeetCode547题 朋友圈\n<!-- more -->\n### 题目\n班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。<br><br>\n\n给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。<br><br><br>\n\n \n\n示例 1：<br>\n输入：\n[[1,1,0],\n [1,1,0],\n [0,0,1]]<br><br>\n输出：2 \n解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。\n第2个学生自己在一个朋友圈。所以返回 2 。<br><br>\n\n示例 2：<br>\n输入：\n[[1,1,0],\n [1,1,1],\n [0,1,1]]<br><br>\n输出：1\n解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。<br><br>\n \n\n提示：<br><br>\n\n1 <= N <= 200\nM[i][i] == 1\nM[i][j] == M[j][i]<br><br>\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/friend-circles\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br>\n\n### 思路\n运用并查集算出相关集合\n#### 并查集不优化代码：\n```C++\nvoid union(int p, int q) {\n    int rootP = find(p);\n    int rootQ = find(q);\n    if (rootP == rootQ)\n        return;\n    // 将两棵树合并为一棵\n    parent[rootP] = rootQ;\n    // parent[rootQ] = rootP 也一样\n    count--; // 两个分量合二为一\n}\n\n/* 返回某个节点 x 的根节点 */\nint find(int x) {\n    // 根节点的 parent[x] == x\n    while (parent[x] != x)\n        x = parent[x];\n    return x;\n}\n\n/* 返回当前的连通分量个数 */\nint count() { \n    return count;\n}\n```\nfind函数是把一棵树直接接到另一棵树下面，这也就造成了树的退化(往链表退化)，就会使时间复杂度达到O(n)，union和connected都是要用到find，所以他们的时间复杂度也是O(n)。<br><br>\n#### 优化方案\n##### 平衡优化\n另外开一个数组记录每棵树的“重量”(节点数),节点数少的接到节点数多的树里面，就可以降低复杂度。<br>\n```C++\nvoid union(int p, int q) {\n    int rootP = find(p);\n    int rootQ = find(q);\n    if (rootP == rootQ)\n        return;\n    \n    // 小树接到大树下面，较平衡\n    if (size[rootP] > size[rootQ]) {\n        parent[rootQ] = rootP;\n        size[rootP] += size[rootQ];\n    } else {\n        parent[rootP] = rootQ;\n        size[rootQ] += size[rootP];\n    }\n    count--;\n}\n```\n<br>\n##### 路径~~亚索~~压缩\n如果我们可以进一步压缩树的高度，让树的高度始终为常数，那find的复杂度就是O(1).\n压缩完是一个根节点下面都是叶子节点，这样树的高度就为常数，非常友好。<br><br>\n```C++\nint find(int x) {\n    int r = x;\n    while (parent[r] != r)\n        r = parent[r]; //找到根节点\n    int i = x, j;\n    while (i != r) { //让每个节点都练到根节点上\n        j = parent[i];\n        parent[i] = r;\n        i = j;\n    }\n    return r;\n}\n```\n<br><br>\n### 代码\n```C++\nclass Solution {\npublic:\n    int counts;\n    vector<int> parent;\n    vector<int> size;\n    void UF(int n) {\n        counts = n;\n        for (int i = 0; i < n; i++) {\n            parent.push_back(i);\n            size.push_back(1);\n        }\n    }\n\n    void Union(int p, int q) {\n        int rootp = find(p);\n        int rootq = find(q);\n        if (rootp == rootq)\n            return;\n        if (size[rootp] > size[rootq]) {\n            parent[rootq] = rootp;\n            size[rootp] += size[rootq];\n        }\n        else {\n            parent[rootp] = rootq;\n            size[rootq] += size[rootp];\n        }\n        counts--;\n    }\n\n    int find(int x) {\n        int r = x;\n        while (parent[r] != r)\n            r = parent[r];\n        int i = x, j;\n        while (i != r) {\n            j = parent[i];\n            parent[i] = r;\n            i = j;\n        }\n        return r;\n    }\n\n    bool connected(int p, int q) {\n        int rootp = find(p);\n        int rootq = find(q);\n        return rootp == rootq;\n    }\n\n    int count() {\n        return counts;\n    }\n\n    int findCircleNum(vector<vector<int>>& M) {\n        UF(M[0].size());\n        for (int i = 0; i < M.size(); i++) {\n            for (int j = 0; j < M[0].size(); j++) {\n                if (M[i][j] == 1) {\n                    Union(i, j);\n                }\n            }\n        }\n        return counts;\n    }\n};\n```",
      "data": {
        "title": "朋友圈(并查集)",
        "date": "2020-12-02 19:02:21",
        "tags": [
          "算法",
          "LeetCode",
          "并查集"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(4).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "LeetCode547题 朋友圈",
      "fileName": "bing-cha-ji"
    },
    {
      "content": "## C/C++\n安装环境g++,gcc,gdb\n终端命令\n```\nsudo apt-get install g++\nsudo apt-get install gcc\nsudo apt-get install gdb\n```\n\n## Java\njdk,jre\n\n",
      "data": {
        "title": "Linux一些环境配置",
        "date": "2020-11-29 18:00:28",
        "tags": [
          "Linux"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/54lqq0%20(1).jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "linux-yi-xie-huan-jing-pei-zhi"
    },
    {
      "content": "记录日常使用linux一些操作\ndeepin永远滴神！！！\n<!-- more -->\n### 安装deb文件\n在deb文件目录下终端输入`sudo apt-get xx.deb`(xx为文件名)\n### 打开tag.gz文件\n情况一(没有可执行文件)：解压缩后终端进入文件目录，然后cd进入/bin，执行./xxx.sh(xxx为程序名)\n情况二(有可执行文件)：直接运行可执行文件即可运行\n### 进入root身份\n终端输入`su`然后输入密码(开机密码)\n如果提示su鉴定故障可以输入`sudo su`\n\n### 双系统切换时间问题\n\n终端输入`timedatectl set-local-rtc 1`\n\n### 双系统开机默认linux更改\n1.ctrl+alt+T打开终端，输入`sudo gedit /etc/default/grub`\n2.验证密码，grub配置文件被打开\n3.将弹出的文件中文本“GRUB-DEFAULT=0”中的0修改为2.（我这里是2，具体数字应该和选择系统的时候win系统的位置-1相同。注意这个-1，因为它是从上到下从0开始排序，所以我这里win系统是第三位，就改成2）\n4.保存文件。←这时可能会弹出警告框，但是一般情况下好像并没有什么关系\n5.在终端输入`sudo update-grub`以更新配置\n6.重启即可发现已经修改完毕\n\n### linux显示系统信息\n终端执行`sudo apt-get install screenfetch`安装screenfetch\n然后执行`screenfetch -s`显示系统信息\n\n### BIOS声音问题\n(deepin)有时候发生错误(比如在QQ输入框没有字的情况下按退格),会出现“嘟”的一声。这是主板BIOS声音没关的问题。\n执行 ``sudo dedit /etc/modprobe.d/alsa-base-blacklist.conf``，输入\n```\nblacklist pcspkr\nblacklist snd_pcsp\n```\n保存后执行 ``sudo update-initramfs -u ``后重启即可。\n",
      "data": {
        "title": "Linux(deepin)日常操作",
        "date": "2020-11-29 17:53:09",
        "tags": [
          "Linux"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/r7zm17%20(1).jpg",
        "isTop": true
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "记录日常使用linux一些操作\ndeepin永远滴神！！！",
      "fileName": "linuxdeepinri-chang-cao-zuo"
    },
    {
      "content": "<!-- # 2020 -->\r\n## 12\r\n### 12/28\r\n做题：买卖股票的最佳时机 IV\r\n这题，，，有点难，之前的简单贪心算法不行了，用递归超时，得用递归+记忆法\r\n动态规划不会用\r\n![](https://cdn.jsdelivr.net/gh/FatePrototype/cdn/img/chrome_vLuS4TuLGB.png)\r\n### 12/27\r\n做题：同构字符串\r\n没读懂题连WA四发，该考虑一下重新上一遍小学语文了0.0\r\n看了半天C++的map，这么多篇文章真是长得都一样，相互抄啊CSDN，看了半天一个都没说map插入可以用`newmap['a'] = 1`的都没有，费半天劲在map上\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_353wBFWJ3v.png)\r\n### 12/26\r\n水题：罗马数字转整数\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_HywjVczLlI.png)\r\n### 12/25\r\n水题：分发饼干\r\n一边吃饼干一遍做分发饼干😏\r\n题不难，没注意题目要求饼干有数量限制WA一发，想到了给的数组不一定是有序的，但是忘了排序了WA一发，正确率又被我愚蠢的拉低了\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_nJyTuhCxCc.png)\r\n\r\n学习一下爬虫，有道的反爬虫确实有意思，改url能用但是翻译效果很差，用js根据时间生成标签，真不戳啊\r\n学习一下堆排序看懂代码\r\n### 12/24\r\n看了眼leetcode的跨年任务：切分木棒，递归完成，不太熟练\r\n做题：分发糖果\r\n一开始想用排序做，然后发现思路是错的，不会做看了题解，顿生一日同吃三顿饭，我应该是白吃了。\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_WyVBq2aY47.png)\r\n### 12/23\r\n今日做题：字符串中的第一个唯一字符\r\nleetcode的第50题，正确率也从之前的30%多涨到47%，一边学算法一边刷leetcode确实掌握了不少东西，比之前硬刷洛谷收货颇多\r\n想用哈希表做，但是不会处理哈希表排序问题看了一眼题解，这可真是，智商压制啊\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_MejJlWndqp.png)\r\n### 12/22\r\n做题：整数转罗马数字\r\n没想到好办法就直接用暴力做了，感觉思维比以前强点了，放以前这种题我估计得WA好几发\r\n然后看了大佬的贪心算法，茅塞顿开！\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_6d4HDwh3pX.png)\r\n### 12/21\r\n解决一下昨天用sqrt投机取巧水的题，采用二分查找可以轻松A\r\n再解决一下前天用辅助数组投机取巧的题，大佬的思路就是牛！\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_4bwNOjnVAz.png)\r\n### 12/20\r\n今日水题：sqrt\r\n用sqrt水过0.0\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_dcbeXPefB6.png)\r\n珍惜眼前人！\r\n### 12/19\r\n今日水题：旋转图像\r\n不让我用辅助数组，我就用😏，反正能过\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_SlewcqsOkT.png)\r\n做完恶心的测试，中途还不能登录了~~不知道这算不算bug~~，我真是被恶心到了\r\n### 12/18\r\n大早上醒来一看epic，好家伙城市天际线外加10刀券，我直接好家伙，E宝永远滴神！！！\r\n今日水题：. 最长公共前缀\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_MxdrMrNJra.png)\r\n水题2：找不同\r\n本来想用哈希表做，但是不会用C++的map，想在题解里找找map的操作，然后找到了位运算的题解，位运算不咋会用但着实好用\r\n写了几个小时把可恶的Web大作业终于弄完了，引用js捣鼓半天，百度了半天都是错的，可恶啊\r\n### 12/17\r\n今日水题：斐波那契数列\r\n本来以为是愉快的通过+1，然后没注意范围递归超时了0.0\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_bPSuU2dO1m.png)\r\n### 12/16\r\n今日做题：恢复二叉搜索树\r\n发现二叉树还有个例题没做，看了书上思路写出来的，二叉搜索树中序遍历就是从小到大遍历所有节点，学到了。不过还是被不讲武德的力扣坑了一发\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_9P0V6UUHaj.png)\r\n### 12/15\r\n今日做题：二叉树的序列化与反序列化\r\n本来想昨天把二叉树专题最后一题给A了，但是昨天感觉脑子不太行了，留到今天才完成。\r\n难度：Hard。但是感觉还是中规中矩~~leetcode的难度真是个谜~~\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_ZwRAZOss7o.png)\r\n水题：二叉树的锯齿形层次遍历\r\n在二叉树层次遍历的基础上每遍历完一层把数组翻转即可，马虎WA了一发\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_coyCqKYeTU.png)\r\n二叉树系列共做16道题，这个专题就先告一段落了，准备开启新的篇章了\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_X5XTBVnaFF.png)\r\n水题三数之和，可能~~我又困了？~~写了半天，双指针忘了咋写了\r\n### 12/14\r\n今日做题：填充每个节点的下一个右侧节点指针（二）\r\n和一差不多，多了一个非完全二叉树，判一下空就行\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_3vKIFv2LKO.png)\r\n带牙套是真别扭0.0，这一下说话都不利索了\r\n做题二：二叉树的最近公共祖先\r\n虽然难度是Easy，但FW的我还是做不出来。卡在公共祖先问题上了\r\n这大佬们写的代码就是牛！\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_HuVaSySO9t.png)\r\n### 12/13\r\n两道水题：二叉树的最大（最小）路径\r\n![](https://sakuratears.cn/post-images/1607838820563.png)\r\n\r\n![](https://sakuratears.cn/post-images/1607838826179.png)\r\n第三道水题：路径之和，没仔细看题是到叶子结点的距离WA了一发\r\n![](https://sakuratears.cn/post-images/1607845910595.png)\r\n第四道：填充每个节点的下一个右侧节点指针\r\n感觉不是很难，但是想了很长时间，~~可能是困的~~\r\n![](https://sakuratears.cn/post-images/1607850506115.png)\r\n### 12/12\r\n今日做题：从前序与中序遍历序列构造二叉树\r\n和昨天题基本相同，因为没思考照抄昨天代码WA一发\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_YKK2ZFll5b.png)\r\n然后水一发前序遍历，后序遍历。\r\n然后是二叉树的层序遍历\r\n这题用BFS思路很简单\r\n![](https://sakuratears.cn/post-images/1607763916321.png)\r\n姜子牙挺好看，从动画效果来看国漫已经很强了，甚至不输日漫，但是这个剧情0.0，有点不太行\r\n### 12/11\r\n今日做题：从中序与后序遍历序列构造二叉树\r\n难度：Medium\r\n掌握了三种遍历方法这个题不算复杂。没考虑左或右空了的情况WA了一发。\r\n不会用vector的切片导致这道题浪费大量时间。\r\n没弄清楚C++的构造函数弄出来的空指针浪费大量时间。\r\n总体来看还算轻松\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_fs9F1heOwA.png)\r\n### 12/10\r\n今日做题：对称二叉树\r\n难度：Easy\r\n做了半天，动态数组，静态数组，队列都用过了，还是不好处理空指针问题，还是用递归好处理\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_Yr4zHVXkCu.png)\r\n然后水一道二叉树中序遍历，这应该是我有史以来做leetcode最快的一次\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_Ui69vsVsk0.png)\r\n### 12/09\r\n今日做题：平衡二叉树\r\n难度：Easy\r\n学会了二叉树的框架做二叉树的题确实简单很多。\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_5oMdVu3xhq.png)\r\n### 12/08\r\n今日做题：二叉树中的最大路径和\r\n难度：Hard\r\n思路大概就是二叉树的后序遍历，DFS\r\n我估计要是不看二叉树的框架我得做上一阵子，laluladong永远滴神！！！\r\n的确用二叉树的思想来做递归题清晰很多\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_NBCfNuqIMe.png)\r\n### 12/07\r\n今日水题：杨辉三角0.0\r\n本来不想水这个题，没啥意义，但是可恶的web作业逼我不得不放弃leetcode写web\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_jh7Ksgpvtc.png)\r\n### 12/06\r\n今日水题1：整数反转\r\n简单题，但是挺多地方爆int，多注意一下方可过题\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_VOi7eJIxTP.png)\r\n今日水题2：字符串转换整数 (atoi)\r\n也不难，和上题一样，各种问题0.0，真是给我恶心到了\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_W7OK5HQTq7.png)\r\n### 12/05\r\n把大多数文章排版了一下，都怪这markdown的换行还要加<br>😑\r\n今日水题：Z 字形变换\r\n看到这题标签没写任何算法，我就开始徒手暴力拆家。然后.......\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_VdGDBQfZm5.png)\r\n最后一个用例1288ms过了，当一道题不涉及算法时，我的代码就开始不优美了~~虽然本来也不优美😒~~\r\n这么一道水题给我整这么半天.\r\n学习一下大佬的们代码\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_mwqB7RYZdm.png)\r\n论学习别人代码~~和一个好的脑子~~的重要性\r\n### 12/04\r\n今日水题：寻找两个正序数组的中位数，极其简单0.0，力扣的难度标签一直就很离谱\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/%E6%88%AA%E5%9B%BE%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20201204145131.png)\r\n外加一道动态规划的题，前一阵子我记得还看过动态规划，然后就不会状态转移了0.0，还好，经过不懈的努力~~抄答案~~终于给过了\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/%E6%88%AA%E5%9B%BE%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20201204201004.png)\r\n\r\n### 12/03\r\n上午简单复习一下数据结构，树和图基本复习完了。\r\n图也没啥东西，依旧是存储，遍历，BFS DFS，最短路径(迪杰斯特拉)，最小生成树(普利姆)(克鲁斯卡尔)，拓扑排序。也没啥了。然后考试森林转二叉树就忘了，还好做对了~~蒙对了~~。\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/QQ%E5%9B%BE%E7%89%8720201203205112.png)\r\n接着撸算法\r\n撸一道并查集的题，并查集这个算法听着是真有点高大上~~主要是简单~~，并查集的优化确实很优美0.0\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/0.jpg)\r\n### 12/02\r\n学习了一下并查集算法，这个算法还是挺友好的。不优化复杂度O(n),经过合并优化查找优化复杂度O(log2n)~~不会latex的菜鸡~~\r\n代码过几天再写吧，复习一下数据结构\r\n树基本上看完了，感觉也没多少东西，存储，遍历，哈弗曼树回溯。也没啥了\r\n### 12/01\r\n今天又是被js折磨的一天，前端真是究极折磨王啊，（~~看来选安卓是对的~~），然后又是一天没咋学习，12的开头不太行啊。\r\n准备准备算法，迎接一下应该是我的最后一次比赛了。加油！\r\n## 11\r\n### 11/30\r\n11月的最后一天．也愿天堂没有文本框和........~~乌迪尔?~~\r\n终于连抄带改把js整完了，这玩意真.....无语\r\n汇编看得有点慢，还差100页，争取一个星期看完吧，时间实在是太紧了\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/0.png)\r\n有一说一，deepin的bug是有点多0.0\r\n### 11/29\r\n挺好一周日放假有没咋学习．上午LOL．下午睡觉＋数据结构作业，普利姆算法看了半天，还是写不出来代码(~~一定是最近学汇编导致的~~)，寒假之前还得补补数据结构，本以为今天不会再写代码了，没想到晚上给我来个Ｃ的大作业．~~我人傻了~~0.0\r\n### 11/28\r\n挺好一下午没咋学习.由于Ubuntu安装软件实在麻烦(typora!!!),QQ微信也不方便,终于,折腾半天还是换了deepin.有一说一deepin做的真的好,完全可以当做日常使用系统,win10就当LOL启动器了😙.\r\n人生苦短,我选deepin!\r\n![](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/screenFetch-2020-11-29_13-20-11.png)\r\n### 11/27\r\n开始记录学习的生活，争取早日成为大佬！",
      "data": {
        "title": "记录学习的日子",
        "date": "2020-11-27 14:35:22",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(9).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ji-lu-xue-xi-de-ri-zi"
    },
    {
      "content": "#### 题目\r\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\r\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\r\n<!-- more -->\r\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><br>\r\n\r\n示例 1:\r\n输入: [7,1,5,3,6,4]\r\n输出: 7\r\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br><br>\r\n\r\n示例 2:\r\n输入: [1,2,3,4,5]\r\n输出: 4\r\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br><br>\r\n\r\n示例 3:\r\n输入: [7,6,4,3,1]\r\n输出: 0\r\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br><br>\r\n\r\n\r\n提示：<br><br>\r\n\r\n1 <= prices.length <= 3 * 10 ^ 4\r\n0 <= prices[i] <= 10 ^ 4<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii<br><br>\r\n\r\n####  思路\r\n第一天买入，第三天卖出的利润是prices[3] - prices[1],也就是(prices[3] - prices[2]) + (prices[2] - porces[1])\r\n可以发现，我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润就可以了，不需要记录区间。<br><br>\r\n\r\n**这就是贪心所贪的地方，只收集正利润。**<br><br>\r\n\r\n![图](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/1604803105-SzWZhG-122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.png)\r\n\r\n#### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxProfit(vector<int>& prices) {\r\n        int result = 0;\r\n        for (int i = 1; i < prices.size(); i++) {\r\n            result += max(prices[i] - prices[i - 1], 0);\r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n<br><br><br>\r\n\r\n\r\n\r\n思路借鉴作者：carlsun-2\r\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/122-mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin-xi/\r\n来源：力扣（LeetCode）",
      "data": {
        "title": "买卖股票的最佳时机 II(贪心)",
        "date": "2020-11-12 20:22:38",
        "tags": [
          "算法",
          "LeetCode",
          "贪心"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(9).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "#### 题目\r\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\r\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\r",
      "fileName": "mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin"
    },
    {
      "content": "一般传递二维数组的基本规则好像是这样的：可以用二维数组名作为实参或者形参，在被调用函数中对形参数组定义时可以可以指定所有维数的大小，也可以省略第一维的大小说明。\r\n<!-- more -->\r\n如：<br><br>\r\n\r\n```C++\r\nvoid Func(int array[3][10]);\r\n\r\nvoid Func(int array[][10]);\r\n```\r\n<br><br>\r\n​    \r\n\r\n二者都是合法而且等价，但是不能把第二维或者更高维的大小省略，如下面的定义是不合法的：<br>\r\n\r\n```C++\r\nvoid Func(int array[][]);\r\n```\r\n<br><br>\r\n将二维数组当作参数的时候，必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的。在学编译原理这么课程的时候知道编译器是这样处理数组的：<br><br>\r\n\r\n对于数组 int p\\[m][n]; 如果要取p\\[i][j]的值(i>=0 && i<m && 0<=j && j < n)，编译器是这样寻址的，它的地址为：<br><br>\r\n\r\n```C++\r\np + i*n + j;\r\n```\r\n<br>\r\n\r\n从以上可以看出，如果我们省略了第二维或者更高维的大小，编译器将不知道如何正确的寻址。但是我们在编写程序的时候却需要用到各个维数都不固定的二维数组作为参数，这就难办了，编译器不能识别阿，怎么办呢？不要着急，编译器虽然不能识别，但是我们完全可以不把它当作一个二维数组，而是把它当作一个普通的指针，再另外加上两个参数指明各个维数，然后我们为二维数组手工寻址，这样就达到了将二维数组作为函数的参数传递的目的，根据这个思想，我们可以把维数固定的参数变为维数随即的参数，例如：<br><br>\r\n\r\n```C++\r\nvoid Func(int array[3][10]); \r\n\r\nvoid Func(int array[][10]);\r\n```\r\n<br>\r\n\r\n变为：<br><br>\r\n\r\n```C++\r\nvoid Func(int **array, int m, int n);\r\n```\r\n<br>\r\n\r\n在转变后的函数中，array[i][j]这样的式子是不对的(不信，大家可以试一下)，因为编译器不能正确的为它寻址，所以我们需要模仿编译器的行为把array[i][j]这样的式子手工转变为<br><br>\r\n\r\n```C++\r\n*((int*)array + n*i + j);\r\n```\r\n\r\n​    <br>\r\n\r\n\r\n\r\n在调用这样的函数的时候，需要注意一下，如下面的例子：<br><br>\r\n\r\n```C++\r\nint a[3][3] = \r\n\r\n    {\r\n{1, 1, 1},\r\n{2, 2, 2},\r\n{3, 3, 3}\r\n};\r\n\r\nFunc(a, 3, 3);\r\n```\r\n<br><br>\r\n  \r\n\r\n\r\n\r\n根据不同编译器不同的设置，可能出现warning 或者error,可以进行强制转换如下调用：  <br><br>\r\n\r\n```C++\r\nFunc((int**)a, 3, 3);\r\n```\r\n<br><br>\r\n\r\n\r\n需要(int\\**）的强制转换，是因为二维数组和二级指针是不同的，a实质上是一个int (*a)[3]，它是一个数组指针，即a[0]是第一维数组的首个元素的地址，a[1]是第二维数组的首个元素的地址，a[2]是第三维数组的首个元素的地址，与int\\**是不同的类型；如果转为int\\**，就失去了像数组指针那样a + i = a + i*3的效果了<br><br>\r\n\r\n而如果又定义一个char \\*p[3]，它是一个一维的指针数组，此时p是指向了一个指针，而不是数组。那么这时如果定义char \\**q = p，就是可以的，而且可以通过q[0]，q[1]来访问字符串。<br><br>\r\n\r\n\r\n\r\n数组和指针这种东西真是太繁琐复杂了，个人愚见，在C++里就尽量使用STL，并且可以用模板的非类型形参来解决这种灵活处理不固定行列数矩阵的函数，Effective C++里面应该有介绍，并且有对这种模板的优化。<br><br>\r\n\r\n转载自CSDN\r\n\r\n",
      "data": {
        "title": "C/C++如何传递二维数组？",
        "date": "2020-11-08 20:06:47",
        "tags": [
          "C/C++"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(8).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "一般传递二维数组的基本规则好像是这样的：可以用二维数组名作为实参或者形参，在被调用函数中对形参数组定义时可以可以指定所有维数的大小，也可以省略第一维的大小说明。\r",
      "fileName": "ccru-he-chuan-di-er-wei-shu-zu"
    },
    {
      "content": "n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\r\n<!-- more -->\r\n\r\n![图](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/8-queens.png)<br><br>\r\n\r\n上图为 8 皇后问题的一种解法。<br><br>\r\n\r\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br><br>\r\n\r\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。<br><br>\r\n\r\n \r\n\r\n示例：<br><br>\r\n\r\n输入：4\r\n输出：[\r\n [\".Q..\",  // 解法 1\r\n  \"...Q\",\r\n  \"Q...\",\r\n  \"..Q.\"],<br><br>\r\n\r\n [\"..Q.\",  // 解法 2\r\n  \"Q...\",\r\n  \"...Q\",\r\n  \".Q..\"]\r\n]\r\n解释: 4 皇后问题存在两个不同的解法。<br><br>\r\n \r\n\r\n提示：<br><br>\r\n\r\n皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。<br><br>\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/n-queens<br><br>\r\n\r\n经典回溯+递归问题，当发现这种情况不行时就回溯到之前的点。<br><br>\r\n\r\n\r\n代码：\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int col[12] = {};//将合适的皇后行数放入数组中\r\n    vector<vector<string>> arr;\r\n    vector<string> brr;\r\n    char crr[100][100];\r\n    int cnumber = 0;\r\n    int num, number = 0, jud = 0, tot = 0;\r\n    bool check(int c, int r)\r\n    {\r\n        int i = 0;\r\n        for (i = 0; i < r; i++)\r\n        {\r\n            if (col[i] == c || (abs(col[i] - c) == abs(i - r)))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    void DFS(int r)\r\n    {\r\n        if (r == num)\r\n        {\r\n            string str = \"\";\r\n            brr.clear();\r\n            for (int j = 0; j < num; j++)\r\n            {\r\n                str = \"\";\r\n                \r\n                for (int i = 0; i < num; i++)\r\n                {\r\n                    if (crr[j][i] == 'Q')\r\n                        str += \"Q\";\r\n                    else\r\n                        str += \".\";\r\n                }\r\n                brr.push_back(str);\r\n            }\r\n            arr.push_back(brr);\r\n            return;\r\n        }\r\n        for (int c = 0; c < num; c++)\r\n        {\r\n            if (check(c, r) == true)\r\n            {\r\n                col[r] = c;\r\n                int i = 0;\r\n                while (i < num)\r\n                {\r\n                    if (i == c)\r\n                    {\r\n                        crr[r][i] = 'Q';\r\n                    }\r\n                    else\r\n                        crr[r][i] = '.';\r\n                    i++;\r\n                }\r\n                DFS(r + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    vector<vector<string>> solveNQueens(int n)\r\n    {\r\n        num = n;\r\n        DFS(0);\r\n        return arr;\r\n    }\r\n};\r\n```\r\n",
      "data": {
        "title": "N皇后(回溯)",
        "date": "2020-11-06 08:56:46",
        "tags": [
          "算法",
          "LeetCode",
          "回溯"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(9).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\r",
      "fileName": "n-huang-hou"
    },
    {
      "content": "DFS BFS例题\r\n<!-- more -->\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/pond-sizes-lcci<br><br>\r\n\r\n你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。<br><br>\r\n\r\n示例：<br><br>\r\n\r\n输入：\r\n[\r\n  [0,2,1,0],\r\n  [0,1,0,1],\r\n  [1,1,0,1],\r\n  [0,1,0,1]\r\n]\r\n输出： [1,2,4]\r\n提示：<br><br>\r\n\r\n0 < len(land) <= 1000\r\n0 < len(land[i]) <= 1000<br><br>\r\n\r\n此题DFS，BFS都可以用。\r\n(代码格式为leetcode模板格式)<br><br>\r\n\r\n代码:\r\n##### BFS\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int n = 0;\r\n    vector<vector<int>> dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};//可以斜着所以是8个方向\r\n    struct Node {int x; int y;};\r\n    queue<Node> q;\r\n    int BFS(int i, int j, vector<vector<int>>& land)\r\n    {\r\n        n = 1;\r\n        Node start, node;\r\n        start.x = i;\r\n        start.y = j;\r\n        land[i][j] = 1;\r\n        q.push(start);\r\n        while (!q.empty()) {\r\n            start = q.front();\r\n            q.pop();\r\n            for (int i = 0; i < 8; i++)\r\n            {\r\n                node.x = start.x + dirs[i][0];\r\n                node.y = start.y + dirs[i][1];\r\n                if (node.x >= 0 && node.x < land.size() && node.y >= 0 && node.y < land[0].size() && land[node.x][node.y] == 0)//判断是否为鱼塘\r\n                {\r\n                    q.push(node);\r\n                    land[node.x][node.y] = 1;//染色\r\n                    n++;\r\n                }\r\n            }\r\n        }\r\n        return n;\r\n    }\r\n\r\n    vector<int> pondSizes(vector<vector<int>>& land) {\r\n        vector<int> arr;\r\n        for (int i = 0; i < land.size(); i++)\r\n        {\r\n            for (int j = 0; j < land[i].size(); j++)\r\n            {\r\n                if (land[i][j] == 0)\r\n                {\r\n                    arr.push_back(BFS(i, j, land));\r\n                }\r\n                else \r\n                {\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        sort(arr.begin(), arr.end());\r\n        return arr;\r\n    }\r\n};\r\n```\r\n<br><br>\r\n##### DFS\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\r\n    struct Node {int x; int y;};\r\n    \r\n    int DFS(int i, int j, vector<vector<int>>& land)\r\n    {\r\n        if (i < 0 || i >= land.size() || j < 0 || j >= land[0].size()) return 0;\r\n        if (land[i][j] != 0) return 0;//判断是否为鱼塘\r\n        land[i][j] = 1;//染色\r\n        Node next;\r\n        int n = 1;\r\n        for (int m = 0; m < 8; m++)\r\n        {\r\n            next.x = i + dirs[m][0];\r\n            next.y = j + dirs[m][1];\r\n            n += DFS(next.x, next.y, land);\r\n        }\r\n        return n;\r\n    }\r\n\r\n    vector<int> pondSizes(vector<vector<int>>& land) {\r\n        vector<int> arr;\r\n        for (int i = 0; i < land.size(); i++)\r\n        {\r\n            for (int j = 0; j < land[i].size(); j++)\r\n            {\r\n                if (land[i][j] == 0)\r\n                {\r\n                    arr.push_back(DFS(i, j, land));\r\n                }\r\n                else \r\n                {\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        sort(arr.begin(), arr.end());\r\n        return arr;\r\n    }\r\n};\r\n```\r\n\r\n",
      "data": {
        "title": "水域大小（DFS）（BFS）",
        "date": "2020-11-04 20:46:03",
        "tags": [
          "算法",
          "LeetCode",
          "搜索"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(8).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "DFS BFS例题\r",
      "fileName": "shui-yu-da-xiao-dfsbfs"
    },
    {
      "content": "#### 题目描述：\r\n给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br><br>\r\n<!-- more -->\r\n注意：\r\n\r\n答案中不可以包含重复的四元组。<br><br>\r\n\r\n示例：\r\n\r\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\r\n\r\n满足要求的四元组集合为：\r\n[\r\n  [-1,  0, 0, 1],\r\n  [-2, -1, 1, 2],\r\n  [-2,  0, 0, 2]\r\n]<br><br>\r\n\r\n来源：力扣18题（LeetCode）\r\n链接：https://leetcode-cn.com/problems/4sum<br><br>\r\n#### 题目分析\r\n此题可以用双指针法解决，先用两个for循环i, j遍历前面，两个指针left, right收缩，当nums[i] + nums[j] + nums[left] + nums[right] == target 时，入数组，然后注意一下去重。（三数之和一个for循环，四数之和用两个，五数之和用三个......）<br><br>\r\n\r\n#### 代码题解\r\n```c++\r\nvector<vector<int>> fourSum(vector<int> &nums, int target)\r\n{\r\n    vector<vector<int>> re;\r\n    sort(nums.begin(), nums.end());\r\n    for (int i = 0; i < nums.size(); i++)\r\n    {\r\n        if (i > 0 && nums[i] == nums[i - 1])//去重\r\n            continue;\r\n        for (int j = i + 1; j < nums.size(); j++)\r\n        {\r\n            if (j > i + 1 && nums[j] == nums[j - 1])//去重\r\n                continue;\r\n            int left = j + 1;\r\n            int right = nums.size() - 1;\r\n            while (left < right)\r\n            {\r\n                if (nums[i] + nums[j] + nums[left] + nums[right] > target)\r\n                {\r\n                    right--;\r\n                }\r\n                else if (nums[i] + nums[j] + nums[left] + nums[right] < target)\r\n                {\r\n                    left++;\r\n                }\r\n                else\r\n                {\r\n                    re.push_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});//下面两个循环去重\r\n                    while (right > left && nums[right] == nums[right - 1])\r\n                    {\r\n                        right--;\r\n                    }\r\n                    while (right > left && nums[left] == nums[left + 1])\r\n                    {\r\n                        left++;\r\n                    }\r\n                    //找到一个适合的后左右指针收缩\r\n                    left++;\r\n                    right--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return re;\r\n}\r\n```\r\n\r\n",
      "data": {
        "title": "四数之和（双指针）",
        "date": "2020-11-01 21:32:08",
        "tags": [
          "算法",
          "LeetCode",
          "双指针"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/54lqq0%20(1).jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "#### 题目描述：\r\n给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br><br>\r",
      "fileName": "si-shu-zhi-he"
    },
    {
      "content": "[TOC]\r\n\r\n#  基本功能\r\n## 基本操作\r\n```python\r\nfrom PyQt5.QtWidgets import QApplication, QWidget\r\n```\r\n```python\r\napp = QApplication(sys.argv)\r\n```\r\n\r\n每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数\r\n\r\n```python\r\nw = QWidget()\r\n```\r\n\r\nQWidget部件是pyqt5所有用户界面对象的基类。他为QWidget提供默认构造函数。\r\n\r\n```python\r\nw.resize(250, 250)\r\n```\r\n\r\nresize方法调整窗口大小\r\n\r\n```python\r\nw.move(300, 300)\r\n```\r\n\r\nmove方法移动窗口在屏幕的位置\r\n\r\n```python\r\nw.setWindowTitle('Simple')\r\n```\r\n\r\n设置窗口标题\r\n\r\n```python\r\nw.show()\r\n```\r\n\r\n显示在屏幕上\r\n\r\n```python\r\nself.setGeometry(300, 300, 300, 300)\r\n```\r\n\r\n设置窗口位置和大小\r\n\r\n\r\n\r\n## 图标\r\n\r\n```python\r\nself.setWindowIcon(QIcon('路径'))\r\n```\r\n\r\n设置窗口的图标\r\n\r\n## 提示语\r\n\r\n```python\r\nfrom PyQt5.QtWidgets import (QWidget, QToolTip, \r\n    QPushButton, QApplication)\r\nfrom PyQt5.QtGui import QFont   \r\n```\r\n\r\n```python\r\nQToolTip.setFont(QFont('SansSerif', 10))\r\n```\r\n\r\n这种静态的方法设置一个用于显示工具提示的字体。我们使用10px滑体字体\r\n\r\n```python\r\nself.setToolTip('This is a <b>QWidget</b> widget')\r\n```\r\n\r\n创建一个提示，我们称之为settooltip()方法。我们可以使用丰富的文本格式\r\n\r\n```python\r\nbtn = QPushButton('Button', self)\r\nbtn.setToolTip('This is a <b>QPushButton</b> widget')\r\n```\r\n\r\n创建一个PushButton并为他设置一个tooltip\r\n\r\n```python\r\nbtn.resize(btn.sizeHint())\r\n```\r\n\r\nbtn.sizeHint()为默认尺寸\r\n\r\n## 关闭窗口\r\n\r\n```python\r\nqbtn = QPushButton('Quit', self)\r\nqbtn.clicked.connect(QCoreApplication.instance().quit)\r\n```\r\n\r\n## 消息框\r\n\r\n```python\r\nfrom PyQt5.QtWidgets import QWidget, QMessageBox, QApplication\r\n```\r\n\r\n```python\r\ndef closeEvent(self, event):\r\n        \r\n        reply = QMessageBox.question(self, 'Message',\r\n            \"Are you sure to quit?\", QMessageBox.Yes | \r\n            QMessageBox.No, QMessageBox.No)\r\n \r\n        if reply == QMessageBox.Yes:\r\n            event.accept()\r\n        else:\r\n            event.ignore()\r\n```\r\n\r\n关闭窗口是出发QCloseEvent。我们需要重写closeEvent方法\r\n\r\n## 窗口显示在屏幕的中间\r\n\r\n```python\r\n#控制窗口显示在屏幕中心的方法    \r\n    def center(self):\r\n        #获得窗口\r\n        qr = self.frameGeometry()\r\n        #获得屏幕中心点\r\n        cp = QDesktopWidget().availableGeometry().center()\r\n        #显示到屏幕中心\r\n        qr.moveCenter(cp)\r\n        self.move(qr.topLeft())\r\n```\r\n\r\nQtGui,QDesktopWidget类提供了用户的桌面信息,包括屏幕大小。\r\n\r\n\r\n\r\n# 布局管理\r\n\r\n## 绝对定位\r\n\r\n```python\r\nlbl1 = QLabel('Zetcode', self)\r\nlbl1.move(15, 10)\r\n \r\nlbl2 = QLabel('tutorials', self)\r\nlbl2.move(35, 40)\r\n        \r\nlbl3 = QLabel('for programmers', self)\r\nlbl3.move(55, 70)        \r\n        \r\nself.setGeometry(300, 300, 250, 150)\r\nself.setWindowTitle('Absolute')    \r\nself.show()\r\n```\r\n\r\n## 框布局 Boxlayout\r\n\r\n```python\r\nokButton = QPushButton(\"OK\")\r\ncancelButton = QPushButton(\"Cancel\")\r\n \r\nhbox = QHBoxLayout()\r\nhbox.addStretch(1)\r\nhbox.addWidget(okButton)\r\nhbox.addWidget(cancelButton)\r\n \r\nvbox = QVBoxLayout()\r\nvbox.addStretch(1)\r\nvbox.addLayout(hbox)\r\n        \r\nself.setLayout(vbox)    \r\n        \r\nself.setGeometry(300, 300, 300, 150)\r\nself.setWindowTitle('Buttons')    \r\nself.show()\r\n```\r\n\r\n我们使用QHBoxLayout和QVBoxLayout，来分别创建横向布局和纵向布局。\r\n\r\n```python\r\nhbox = QHBoxLayout()\r\nhbox.addStretch(1)\r\nhbox.addWidget(okButton)\r\nhbox.addWidget(cancelButton)\r\n```\r\n\r\n我们创建一个水平布局和添加一个伸展因子和两个按钮。两个按钮前的伸展增加了一个可伸缩的空间。这将推动他们靠右显示。\r\n\r\n```python\r\nvbox = QVBoxLayout()\r\nvbox.addStretch(1)\r\nvbox.addLayout(hbox)\r\n```\r\n\r\n创建一个垂直布局，并添加伸展因子，让水平布局显示在窗口底部\r\n\r\n```python\r\nself.setLayout(vbox)\r\n```\r\n\r\n最后,我们设置窗口的布局界面\r\n\r\n## 表格布局 QGridLayout\r\n\r\n```python\r\ngrid = QGridLayout()\r\nself.setLayout(grid)\r\n\r\nnames = ['Cls', 'Bck', '', 'Close',\r\n          '7', '8', '9', '/',\r\n           '4', '5', '6', '*',\r\n          '1', '2', '3', '-',\r\n             '0', '.', '=', '+']\r\n\r\n positions = [(i, j) for i in range(5) for j in range(4)]\r\n\r\n  for position, name in zip(positions, names):\r\n\r\n       if name == '':\r\n            continue\r\n        button = QPushButton(name)\r\n        grid.addWidget(button, *position)\r\n\r\n```\r\n\r\n```python\r\ngrid = QGridLayout()\r\nself.setLayout(grid)\r\n```\r\n\r\nQGridLayout的实例被创建并设置应用程序窗口的布局。\r\n\r\nnames列表为这些按钮的标签\r\n\r\n## 评论的例子\r\n\r\n```python\r\ndef initUI(self):\r\n\r\n    title = QLabel('Title')\r\n    author = QLabel('Author')\r\n    review = QLabel('Review')\r\n\r\n    titleEdit = QLineEdit()\r\n    authorEdit = QLineEdit()\r\n    reviewEdit = QTextEdit()\r\n\r\n    grid = QGridLayout()\r\n    grid.setSpacing(10)\r\n\r\n    grid.addWidget(title, 1, 0)\r\n    grid.addWidget(titleEdit, 1, 1)\r\n\r\n    grid.addWidget(author, 2, 0)\r\n    grid.addWidget(authorEdit, 2, 1)\r\n\r\n    grid.addWidget(review, 3, 0)\r\n    grid.addWidget(reviewEdit, 3, 1, 5, 1)\r\n\r\n    self.setLayout(grid)\r\n\r\n    self.setGeometry(300, 300, 350, 300)\r\n    self.setWindowTitle('Review')\r\n    self.show()\r\n```\r\n\r\n我们创建一个窗口,其中有三个标签,两个行编辑和一个文本编辑窗口小控件。然后使用QGridLayout完成布局。\r\n\r\n```python\r\ngrid = QGridLayout()\r\ngrid.setSpacing(10)\r\n```\r\n\r\n创建一个网格布局和设置组件之间的间距。\r\n\r\n```python\r\ngrid.addWidget(reviewEdit, 3, 1, 5, 1)\r\n```\r\n\r\n在添加一个小的控件到网格的时候,我们可以提供小部件的行和列跨。在例子中,reviewEdit控件跨度5行。\r\n\r\n# 菜单和工具栏\r\n\r\n## 状态栏\r\n\r\n```python\r\ndef initUI(self):\r\n\r\n    self.statusBar().showMessage('Ready')\r\n\r\n    self.setGeometry(300, 300, 250, 150)\r\n    self.setWindowTitle('Statusbar')\r\n    self.show()\r\n\r\n```\r\n\r\n用QMainWindow创建状态栏的小窗口\r\n\r\n```python\r\nself.statusBar().showMessage('Ready')\r\n```\r\n\r\nQMainWindow类第一次调用statusBar()方法创建一个状态栏。后续调用返回的状态栏对象。showMessage()状态栏上显示一条消息。\r\n\r\n## 菜单栏\r\n\r\n菜单栏是常见的窗口应用程序的一部分。(Mac OS将菜单条不同。得到类似的结果,我们可以添加以下行:menubar.setNativeMenuBar(假)。)\r\n\r\n```python\r\ndef initUI(self):\r\n\r\n    exitAction = QAction(QIcon('exit.png'), '&Exit', self)\r\n    exitAction.setShortcut('Ctrl+Q')\r\n    exitAction.setStatusTip('Exit application')\r\n    exitAction.triggered.connect(qApp.quit)\r\n\r\n    self.statusBar()\r\n\r\n    # 创建一个菜单栏\r\n    menubar = self.menuBar()\r\n    # 添加菜单\r\n    fileMenu = menubar.addMenu('&File')\r\n    # 添加事件\r\n    fileMenu.addAction(exitAction)\r\n\r\n    self.setGeometry(300, 300, 300, 200)\r\n    self.setWindowTitle('Menubar')\r\n    self.show()\r\n\r\n```\r\n\r\n```python\r\nexitAction = QAction(QIcon('exit.png'), '&Exit', self)        \r\nexitAction.setShortcut('Ctrl+Q')\r\nexitAction.setStatusTip('Exit application')\r\n```\r\n\r\nQAction可以操作菜单栏,工具栏,或自定义键盘快捷键。上面三行,我们创建一个事件和一个特定的图标和一个“退出”的标签。然后,在定义该操作的快捷键。\r\n第三行创建一个鼠标指针悬停在该菜单项上时的提示。\r\n\r\n```python\r\nexitAction.triggered.connect(qApp.quit)\r\n```\r\n\r\n当我们点击菜单的时候，调用qApp.quit,终止应用程序。\r\n\r\n## 工具栏\r\n\r\n```python\r\ndef initUI(self):\r\n\r\n    exitAction = QAction(QIcon('exit24.png'), 'Exit', self)\r\n    exitAction.setShortcut('Ctrl+Q')\r\n    exitAction.triggered.connect(qApp.quit)\r\n\r\n    self.toolbar = self.addToolBar('Exit')\r\n    self.toolbar.addAction(exitAction)\r\n\r\n    self.setGeometry(300, 300, 300, 200)\r\n    self.setWindowTitle('Toolbar')\r\n    self.show()\r\n\r\n```\r\n\r\n在上面的例子中,我们创建一个简单的工具栏。工具栏有有一个按钮,点击关闭窗口。\r\n\r\n```python\r\nexitAction = QAction(QIcon('exit24.png'), 'Exit', self)\r\nexitAction.setShortcut('Ctrl+Q')\r\nexitAction.triggered.connect(qApp.quit)\r\n```\r\n\r\n类似于上面的菜单栏的例子,我们创建一个QAction事件。该事件有一个标签、图标和快捷键。退出窗口的方法\r\n\r\n## 把他们放在一起\r\n\r\n```python\r\nimport sys\r\nfrom PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplication\r\nfrom PyQt5.QtGui import QIcon\r\n \r\n \r\nclass Example(QMainWindow):\r\n    \r\n    def __init__(self):\r\n        super().__init__()\r\n        \r\n        self.initUI()\r\n        \r\n        \r\n    def initUI(self):               \r\n        \r\n        textEdit = QTextEdit()\r\n        self.setCentralWidget(textEdit)\r\n \r\n        exitAction = QAction(QIcon('exit24.png'), 'Exit', self)\r\n        exitAction.setShortcut('Ctrl+Q')\r\n        exitAction.setStatusTip('Exit application')\r\n        exitAction.triggered.connect(self.close)\r\n \r\n        self.statusBar()\r\n \r\n        menubar = self.menuBar()\r\n        fileMenu = menubar.addMenu('&File')\r\n        fileMenu.addAction(exitAction)\r\n \r\n        toolbar = self.addToolBar('Exit')\r\n        toolbar.addAction(exitAction)\r\n        \r\n        self.setGeometry(300, 300, 350, 250)\r\n        self.setWindowTitle('Main window')    \r\n        self.show()\r\n        \r\n        \r\nif __name__ == '__main__':\r\n    \r\n    app = QApplication(sys.argv)\r\n    ex = Example()\r\n    sys.exit(app.exec_())\r\n```\r\n\r\n```python\r\ntextEdit = QTextEdit()\r\nself.setCentralWidget(textEdit)\r\n```\r\n\r\n我们创建了一个QTextEdit,并把他设置为窗口的布局",
      "data": {
        "title": "PyQt5总结",
        "date": "2020-10-30 20:24:46",
        "tags": [
          "Python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(4).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "pyqt5-zong-jie"
    },
    {
      "content": "首先，安装 Python 图像处理库 pillow（PIL）\r\nargparse是 Python 标准库中推荐的命令行解析模块。\r\n具体方法可以查看官方文档是 https://docs.python.org/zh-cn/3/howto/argparse.html\r\n```Python\r\n# -*- coding=utf-8 -*-\r\n\r\nfrom PIL import Image\r\nimport argparse\r\n\r\n#命令行输入参数处理\r\nparser = argparse.ArgumentParser()\r\n\r\nparser.add_argument('file')     #输入文件\r\nparser.add_argument('-o', '--output')   #输出文件\r\nparser.add_argument('--width', type = int, default = 80) #输出字符画宽\r\nparser.add_argument('--height', type = int, default = 80) #输出字符画高\r\n\r\n#获取参数\r\nargs = parser.parse_args()\r\n\r\nIMG = args.file\r\nWIDTH = args.width\r\nHEIGHT = args.height\r\nOUTPUT = args.output\r\n\r\nascii_char = list(\"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\\\"^`'. \")\r\n\r\n# 将256灰度映射到70个字符上\r\ndef get_char(r,g,b,alpha = 256):\r\n    if alpha == 0:\r\n        return ' '\r\n    length = len(ascii_char)\r\n    gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)\r\n\r\n    unit = (256.0 + 1)/length\r\n    return ascii_char[int(gray/unit)]\r\n\r\nif __name__ == '__main__':\r\n\r\n    # 打开并调整图片的宽和高\r\n    im = Image.open(IMG)\r\n    im = im.resize((WIDTH,HEIGHT), Image.NEAREST)\r\n\r\n    # 初始化输出的字符串\r\n    txt = \"\"\r\n\r\n    # 遍历图片中的每一行\r\n    for i in range(HEIGHT):\r\n        # 遍历该行中的每一列\r\n        for j in range(WIDTH):\r\n            # 将 (j,i) 坐标的 RGB 像素转为字符后添加到 txt 字符串\r\n            txt += get_char(*im.getpixel((j,i)))\r\n        # 遍历完一行后需要增加换行符\r\n        txt += '\\n'\r\n    # 输出到屏幕\r\n    print(txt)\r\n\r\n    # 字符画输出到文件\r\n    if OUTPUT:\r\n        with open(OUTPUT,'w') as f:\r\n            f.write(txt)\r\n    else:\r\n        with open(\"output.txt\",'w') as f:\r\n            f.write(txt)\r\n\r\n```\r\n使用图片https://labfile.oss.aliyuncs.com/courses/370/ascii_dora.png\r\n在命令行使用命令\r\n`python ascii.py ascii_dora.png`\r\n效果：\r\n![效果图](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/notepad_DvSgM1djjf.png)",
      "data": {
        "title": "Python实现图片转字符画",
        "date": "2020-10-26 20:37:31",
        "tags": [
          "Python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(1).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-shi-xian-tu-pian-zhuan-zi-fu-hua"
    },
    {
      "content": "由于政策原因使用pip(pycharm也是)装第三方库有时会很慢有时会失败，有条件的可以使用不可描述方法进行安装或者我们可以使用清华源镜像装库\r\n链接https://mirrors.tuna.tsinghua.edu.cn/help/pypi/\r\n<!-- more -->",
      "data": {
        "title": "Python解决用pip装第三方库慢的方法",
        "date": "2020-10-24 18:48:49",
        "tags": [
          "Python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/gridea-zhu-ti-fog-geng-xin-ri-zhi.jpeg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-jie-jue-yong-pip-zhuang-di-san-fang-ku-man-de-fang-fa"
    },
    {
      "content": "> 欢迎来到我的小站呀，很高兴遇见你！🤝\r\n\r\n## 🏠 关于本站\r\n在使用一段时间hexo后还是放弃了hexo选择了简单方便的Gridea（其实就是不会用hexo）\r\n## 👨‍💻 关于博主\r\n一枚啥也不会的菜鸡程序猿\r\n主攻Java开发，Android开发（狗头保命！）\r\n## 📬 联系我呀\r\nQQ：2538598846\r\n微信：2538598846\r\n欢迎好友交流😎\r\n\r\n",
      "data": {
        "title": "奇妙的自我描述",
        "date": "2020-10-23 19:09:48",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(3).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "qi-miao-de-zi-wo-miao-shu"
    },
    {
      "content": "KMP算法是一种**字符串匹配**算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。本文将引导您学习KMP算法。\r\n<!-- more -->\r\n本文转载自知乎“洛谷网校 阮行止”\r\n\r\n网址：https://www.zhihu.com/question/21923021/answer/1032665486?utm_source=qq&utm_medium=social&utm_oi=952480495343259648\r\n\r\n#### 字符串匹配问题\r\n 所谓字符串匹配，是这样一种问题：“字符串 P 是否为字符串 S 的子串？如果是，它出现在 S 的哪些位置？” 其中 S 称为**主串**；P 称为**模式串**。下面的图片展示了一个例子。\r\n\r\n![图](https://pic4.zhimg.com/v2-2967e415f490e03a2a9400a92b185310_r.jpg?source=1940ef5c)\r\n\r\n主串是莎翁那句著名的 “to be or not to be”，这里删去了空格。“no” 这个模式串的匹配结果是“出现了一次，从S[6]开始”；“ob”这个模式串的匹配结果是“出现了两次，分别从s[1]、s[10]开始”。按惯例，主串和模式串都以0开始编号。\r\n　　字符串匹配是一个非常频繁的任务。例如，今有一份名单，你急切地想知道自己在不在名单上；又如，假设你拿到了一份文献，你希望快速地找到某个关键字（keyword）所在的章节……凡此种种，不胜枚举。\r\n　　我们先从最朴素的Brute-Force算法开始讲起。\r\n　　\r\n#### Brute-Force\r\n\r\n顾名思义，Brute-Force是一个纯暴力算法。说句题外话，我怀疑，“暴力”一词在算法领域表示“穷举、极低效率的实现”，可能就是源于这个英文词。\r\n　　首先，我们应该如何实现两个字符串 A,B 的比较？所谓**字符串比较**，就是问“两个字符串是否相等”。最朴素的思想，就是从前往后逐字符比较，一旦遇到不相同的字符，就返回False；如果两个字符串都结束了，仍然没有出现不对应的字符，则返回True。实现如下：\r\n![图](https://pic2.zhimg.com/80/v2-f9a7d55f60e346529f70c409dfcda786_720w.jpg?source=1940ef5c)\r\n\r\n既然我们可以知道“两个字符串是否相等”，那么最朴素的字符串匹配算法 Brute-Force 就呼之欲出了——\r\n· 枚举 i = 0, 1, 2 ... , len(S)-len(P)\r\n· 将 S[i : i+len(P)] 与 P 作比较。如果一致，则找到了一个匹配。\r\n\r\n现在我们来模拟 Brute-Force 算法，对主串 “AAAAAABC” 和模式串 “AAAB” 做匹配：\r\n![图](https://pic3.zhimg.com/80/v2-1892c7f6bee02e0fc7baf22aaef7151f_720w.jpg?source=1940ef5c)\r\n这是一个清晰明了的算法，实现也极其简单。下面给出Python和C++的实现：\r\n![图](https://pic4.zhimg.com/80/v2-36589bc0279263ec8641a295aea66a0c_720w.jpg?source=1940ef5c)\r\n![图](https://pic4.zhimg.com/80/v2-ed28c8d60516720cc38c48d135091a58_720w.jpg?source=1940ef5c)\r\n\r\n我们成功实现了 Brute-Force 算法。现在，我们需要对它的时间复杂度做一点讨论。按照惯例，记 n = |S| 为串 S 的长度，m = |P| 为串 P 的长度。\r\n　　考虑“字符串比较”这个小任务的复杂度。最坏情况发生在：两个字符串唯一的差别在最后一个字符。这种情况下，字符串比较必须走完整个字符串，才能给出结果，因此复杂度是 O(len) 的。　　\r\n\r\n　　由此，不难想到 Brute-Force 算法所面对的最坏情况：主串形如“AAAAAAAAAAA...B”，而模式串形如“AAAAA...B”。每次字符串比较都需要付出 |P| 次字符比较的代价，总共需要比较 |S| - |P| + 1次，因此总时间复杂度是  ![[公式]](https://www.zhihu.com/equation?tex=O%28%7CP%7C%5Ccdot+%28%7CS%7C+-+%7CP%7C+%2B+1%29+%29) . 考虑到主串一般比模式串长很多，故 Brute-Force 的复杂度是 ![[公式]](https://www.zhihu.com/equation?tex=O%28%7CP%7C+%5Ccdot+%7CS%7C%29) ，也就是 O(nm)的。这太慢了！\r\n\r\n\r\n\r\n#### Brute-Force的改进思路\r\n经过刚刚的分析，您已经看到，Brute-Force 慢得像爬一样。它最坏的情况如下图所示：\r\n![图](https://pic4.zhimg.com/80/v2-4fe5612ff13a6286e1a8e50a0b06cd96_720w.jpg?source=1940ef5c)\r\n\r\n我们很难降低字符串比较的复杂度（因为比较两个字符串，真的只能逐个比较字符）。因此，我们考虑**降低比较的趟数**。如果比较的趟数能降到足够低，那么总的复杂度也将会下降很多。　　要优化一个算法，首先要回答的问题是“我手上有什么信息？”　我们手上的信息是否足够、是否有效，决定了我们能把算法优化到何种程度。请记住：**尽可能利用残余的信息，是KMP算法的思想所在**。\r\n　　在 Brute-Force 中，如果从 S[i] 开始的那一趟比较失败了，算法会直接开始尝试从 S[i+1] 开始比较。这种行为，属于典型的“没有从之前的错误中学到东西”。我们应当注意到，一次失败的匹配，会给我们提供宝贵的信息——如果 S[i : i+len(P)] 与 P 的匹配是在第 r 个位置失败的，那么从 S[i] 开始的 (r-1) 个连续字符，一定与 P 的前 (r-1) 个字符一模一样！\r\n\r\n![图](https://pic2.zhimg.com/80/v2-7dc61b0836af61e302d9474eeeecfe83_720w.jpg?source=1940ef5c)\r\n\r\n需要实现的任务是“字符串匹配”，而每一次失败都会给我们换来一些信息——能告诉我们，主串的某一个子串等于模式串的某一个前缀。但是这又有什么用呢？\r\n\r\n#### 跳过不可能成功的字符串比较\r\n\r\n有些趟字符串比较是有可能会成功的；有些则毫无可能。我们刚刚提到过，优化 Brute-Force 的路线是“尽量减少比较的趟数”，而如果我们跳过那些**绝不可能成功的**字符串比较，则可以希望复杂度降低到能接受的范围。\r\n　　那么，哪些字符串比较是不可能成功的？来看一个例子。已知信息如下：\r\n\r\n- 模式串 P = \"abcabd\".\r\n- 和主串从S[0]开始匹配时，在 P[5] 处失配。\r\n\r\n![img](https://pic4.zhimg.com/50/v2-372dc6c567ba53a1e4559fdb0cb6b206_hd.jpg?source=1940ef5c)\r\n\r\n\r\n\r\n首先，利用上一节的结论。既然是在 P[5] 失配的，那么说明 S[0:5] 等于 P[0:5]，即\"abcab\". 现在我们来考虑：从 S[1]、S[2]、S[3] 开始的匹配尝试，有没有可能成功？\r\n　　从 S[1] 开始肯定没办法成功，因为 S[1] = P[1] = 'b'，和 P[0] 并不相等。从 S[2] 开始也是没戏的，因为 S[2] = P[2] = 'c'，并不等于P[0]. 但是从 S[3] 开始是有可能成功的——至少按照已知的信息，我们推不出矛盾。\r\n\r\n![img](https://pic4.zhimg.com/50/v2-67dd66b86323d3d08f976589cf712a1a_hd.jpg?source=1940ef5c)\r\n\r\n　　带着“跳过不可能成功的尝试”的思想，我们来看next数组。\r\n\r\n\r\n\r\n#### next数组\r\n\r\nnext数组是对于模式串而言的。P 的 next 数组定义为：next[i] 表示 P[0] ~ P[i] 这一个子串，使得 **前k个字符**恰等于**后k个字符** 的最大的k. 特别地，k不能取i+1（因为这个子串一共才 i+1 个字符，自己肯定与自己相等，就没有意义了）。\r\n\r\n![img](https://pic2.zhimg.com/80/v2-49c7168b5184cc1744459f325e426a4a_720w.jpg?source=1940ef5c)\r\n\r\n　　上图给出了一个例子。P=\"abcabd\"时，next[4]=2，这是因为P[0] ~ P[4] 这个子串是\"abcab\"，前两个字符与后两个字符相等，因此next[4]取2. 而next[5]=0，是因为\"abcabd\"找不到前缀与后缀相同，因此只能取0. \r\n\r\n　　如果把模式串视为一把标尺，在主串上移动，那么 Brute-Force 就是每次失配之后只右移一位；改进算法则是**每次失配之后，移很多位**，跳过那些不可能匹配成功的位置。但是该如何确定要移多少位呢？\r\n\r\n![img](https://pic4.zhimg.com/80/v2-d6c6d433813595dce5aad08b40dc0b72_720w.jpg?source=1940ef5c)\r\n\r\n　　在 S[0] 尝试匹配，失配于 S[3] <=> P[3] 之后，我们直接把模式串往右移了两位，让 S[3] 对准 P[1]. 接着继续匹配，失配于 S[8] <=> P[6], 接下来我们把 P 往右平移了三位，把 S[8] 对准 P[3]. 此后继续匹配直到成功。\r\n　　我们应该如何移动这把标尺？**很明显，如图中蓝色箭头所示，旧的后缀要与新的前缀一致**（如果不一致，那就肯定没法匹配上了）！\r\n\r\n\r\n　　回忆next数组的性质：P[0] 到 P[i] 这一段子串中，前next[i]个字符与后next[i]个字符一模一样。既然如此，如果失配在 P[r], 那么P[0]~P[r-1]这一段里面，**前next[r-1]个字符恰好和后next[r-1]个字符相等**——也就是说，我们可以拿长度为 next[r-1] 的那一段前缀，来顶替当前后缀的位置，让匹配继续下去！\r\n　　您可以验证一下上面的匹配例子：P[3]失配后，把P[next[3-1]]也就是P[1]对准了主串刚刚失配的那一位；P[6]失配后，把P[next[6-1]]也就是P[3]对准了主串刚刚失配的那一位。\r\n\r\n![img](https://pic2.zhimg.com/80/v2-6ddb50d021e9fa660b5add8ea225383a_720w.jpg?source=1940ef5c)\r\n\r\n　　如上图所示，绿色部分是成功匹配，失配于红色部分。深绿色手绘线条标出了相等的前缀和后缀，**其长度为next[右端]**. 由于手绘线条部分的字符是一样的，所以直接把前面那条移到后面那条的位置。因此说，**next数组为我们如何移动标尺提供了依据**。接下来，我们实现这个优化的算法。\r\n\r\n\r\n\r\n#### 利用next数组进行匹配\r\n\r\n了解了利用next数组加速字符串匹配的原理，我们接下来代码实现之。分为两个部分：建立next数组、利用next数组进行匹配。\r\n　　首先是建立next数组。我们暂且用最朴素的做法，以后再回来优化：\r\n\r\n![img](https://pic1.zhimg.com/50/v2-1dda8f33e5847449cd9784e76e972cab_hd.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-1dda8f33e5847449cd9784e76e972cab_720w.jpg?source=1940ef5c)\r\n\r\n　　如上图代码所示，直接根据next数组的定义来建立next数组。不难发现它的复杂度是 ![[公式]](https://www.zhihu.com/equation?tex=O%28m%5E2%29) 的。\r\n　　接下来，实现利用next数组加速字符串匹配。代码如下：\r\n\r\n![img](https://pic2.zhimg.com/50/v2-a6bd81af7cf9bbda32b2cfb0e4858276_hd.jpg?source=1940ef5c)\r\n\r\n　　如何分析这个字符串匹配的复杂度呢？乍一看，pos值可能不停地变成next[pos-1]，代价会很高；但我们使用摊还分析，显然pos值一共顶多自增len(S)次，因此pos值减少的次数不会高于len(S)次。由此，复杂度是可以接受的，不难分析出整个匹配算法的时间复杂度：O(n+m).\r\n\r\n\r\n\r\n#### 快速求next数组\r\n\r\n终于来到了我们最后一个问题——如何快速构建next数组。\r\n　　首先说一句：快速构建next数组，是KMP算法的精髓所在，核心思想是“**P自己与自己做匹配**”。\r\n　　为什么这样说呢？回顾next数组的完整定义：\r\n\r\n- 定义 “k-前缀” 为一个字符串的前 k 个字符； “k-后缀” 为一个字符串的后 k 个字符。k 必须小于字符串长度。 \r\n- next[x] 定义为： P[0]~P[x] 这一段字符串，使得**k-前缀恰等于k-后缀**的最大的k.\r\n\r\n　　这个定义中，不知不觉地就包含了一个匹配——前缀和后缀相等。接下来，我们考虑采用递推的方式求出next数组。如果next[0], next[1], ... next[x-1]均已知，那么如何求出 next[x] 呢？\r\n\r\n　　来分情况讨论。首先，已经知道了 next[x-1]（以下记为now），如果 P[x] 与 P[now] 一样，那最长相等前后缀的长度就可以扩展一位，很明显 next[x] = now + 1. 图示如下。\r\n\r\n![img](https://pic3.zhimg.com/80/v2-6d6a40331cd9e44bfccd27ac5a764618_720w.jpg?source=1940ef5c)\r\n\r\n\r\n　　刚刚解决了 P[x] = P[now] 的情况。那如果 P[x] 与 P[now] 不一样，又该怎么办？\r\n\r\n![img](https://pic1.zhimg.com/80/v2-ce1d46a1e3603b07a13789b6ece6022f_720w.jpg?source=1940ef5c)\r\n\r\n　　如图。长度为 now 的子串 A 和子串 B 是 P[0]~P[x-1] 中最长的公共前后缀。可惜 A 右边的字符和 B 右边的那个字符不相等，next[x]不能改成 now+1 了。因此，我们应该**缩短这个now**，把它改成小一点的值，再来试试 P[x] 是否等于 P[now].\r\n　　now该缩小到多少呢？显然，我们不想让now缩小太多。因此我们决定，在保持“P[0]~P[x-1]的now-前缀仍然等于now-后缀”的前提下，让这个新的now尽可能大一点。 P[0]~P[x-1] 的公共前后缀，前缀一定落在串A里面、后缀一定落在串B里面。换句话讲：接下来now应该改成：使得 **A的k-前缀**等于**B的k-后缀** 的最大的k.\r\n　　您应该已经注意到了一个非常强的性质——**串A和串B是相同的**！B的后缀等于A的后缀！因此，使得A的k-前缀等于B的k-后缀的最大的k，其实就是串A的最长公共前后缀的长度 —— next[now-1]！\r\n\r\n![img](https://pic2.zhimg.com/80/v2-c5ff4faaab9c3e13690deb86d8d17d71_720w.jpg?source=1940ef5c)\r\n\r\n　　来看上面的例子。当P[now]与P[x]不相等的时候，我们需要缩小now——把now变成next[now-1]，直到P[now]=P[x]为止。P[now]=P[x]时，就可以直接向右扩展了。\r\n\r\n　　代码实现如下：\r\n\r\n![img](https://pic4.zhimg.com/50/v2-010a582b0c92a92044c43a2a2ea88928_hd.jpg?source=1940ef5c)![img](https://pic4.zhimg.com/80/v2-010a582b0c92a92044c43a2a2ea88928_720w.jpg?source=1940ef5c)\r\n\r\n　　应用摊还分析，不难证明构建next数组的时间复杂度是O(m)的。至此，我们以O(n+m)的时间复杂度，实现了构建next数组、利用next数组进行字符串匹配。\r\n\r\n　　以上就是KMP算法。它于1977年被提出，全称 Knuth–Morris–Pratt 算法。让我们记住前辈们的名字：[Donald Knuth](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Donald_Knuth)(K), [James H. Morris](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/James_H._Morris)(M), [Vaughan Pratt](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Vaughan_Pratt)(P).\r\n\r\n\r\n\r\n\r\n作者：阮行止\r\n链接：https://www.zhihu.com/question/21923021/answer/1032665486\r\n来源：知乎",
      "data": {
        "title": "KMP算法",
        "date": "2020-10-23 15:02:13",
        "tags": [
          "算法"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(7).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "KMP算法是一种**字符串匹配**算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。本文将引导您学习KMP算法。\r",
      "fileName": "kmp-suan-fa"
    },
    {
      "content": "为了展示初级排序算法性质的价值，接下来我们将学习一种基于插入排序的快速的排序算法。\r\n<!-- more -->\r\n对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要№1次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。\r\n\r\n实现希尔排序的一种方法是对于每个h，用插入排序将h个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在h-子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插人排序的代码中将移动元素的距离由1改为h即可。这样，希尔排序的实现就转化为了一个类似于插人排序但使用不同增量的过程。\r\n\r\n希尔排序为插入排序高级版，先把几个部分的数组用插入排序排好，然后再把这几个分散数组排序成有序数组。\r\n确定一个增量h（h可以是数组总长/3 or /2），每次循环完增量变小直到为1，每次把分散的数组整合成一个大的有序数组，直到增量为1时，整个数组排序完成。\r\n\r\n```C/C++\r\nvoid shellsort(int a[], int m)\r\n{\r\n    int h = m / 2; //确定增量h\r\n    for (h; h >= 1; h /= 2) //每次增量变小\r\n    {\r\n        for (int i = h; i < m; i += h)\r\n        {\r\n            for (int j = i; j >= 0 && j - h >= 0 && a[j] < a[j - h]; j -= h)\r\n            {\r\n                int temp = a[j];\r\n                a[j] = a[j - h];\r\n                a[j - h] = temp;\r\n            }\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i < m; i++)\r\n    {\r\n        cout << a[i] << \" \";\r\n    }\r\n}\r\n```",
      "data": {
        "title": "希尔排序",
        "date": "2020-10-23 15:00:09",
        "tags": [
          "算法",
          "排序"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(4).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "为了展示初级排序算法性质的价值，接下来我们将学习一种基于插入排序的快速的排序算法。\r",
      "fileName": "xi-er-pai-xu"
    },
    {
      "content": "快速排序的特点是他是原地排序（只需要一个很小的辅助栈），且长度为N的数组时间复杂度为NlgN。\r\n<!-- more -->\r\n快速排序是一种分治的算法，他将一个数组分成两个数组，将两部分独立排序，在快排中切分的位置取决于数组的内容。\r\n取首元素为切分元素，比切分元素小的放到左边，比切分元素大的放到右边，再把两个数组切分，最后有序\r\n![图](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/QQ%E5%9B%BE%E7%89%8720201015164728.jpg)\r\n```C/C++\r\nvoid qsort(int a[], int lo, int hi)\r\n{\r\n    if (lo >= hi)\r\n        return;\r\n    int i, j, m, temp, mid;\r\n    m = a[lo]; //切分元素\r\n    i = lo; //下面循环时i和j就会先自增/自减1再判断，所以i为头元素，j为尾元素 - 1\r\n    j = hi + 1;\r\n    while (true)\r\n    {\r\n        while (a[++i] < m)\r\n        {\r\n            if (i == hi)//直到循环到右边界也没有找到比切分元素大的元素\r\n                break;\r\n        }\r\n        while (a[--j] > m)\r\n        {\r\n            if (j == lo)//直到循环到左边界也没有找到比切分元素小的元素\r\n                break;\r\n        }\r\n        if (i >= j)//当i的位置在j的右边，a[i] > a[j],不可以交换\r\n            break;\r\n        int temp = a[i];\r\n        a[i] = a[j];\r\n        a[j] = temp;\r\n    }\r\n    temp = a[lo];\r\n    a[lo] = a[j];\r\n    a[j] = temp;\r\n    mid = j;\r\n    qsort(a, lo, mid - 1);\r\n    qsort(a, mid + 1, hi);\r\n}\r\n```",
      "data": {
        "title": "快速排序",
        "date": "2020-10-23 14:59:36",
        "tags": [
          "算法",
          "排序"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(3).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "快速排序的特点是他是原地排序（只需要一个很小的辅助栈），且长度为N的数组时间复杂度为NlgN。\r",
      "fileName": "kuai-su-pai-xu"
    },
    {
      "content": "归并排序将两个有序的排列归并为一个有序的排列。\r\n<!-- more -->\r\n归并算法都基于归并这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：归并排序。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来：你将会看到，归并排序最\r\n吸引人的性质是它能够保证将任意长度为，的数组排序所需时间和，成正比；它的主要缺点则是它所需的额外空间。简单的归并排序如图所示。\r\n\r\n![图](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_6xnNTxUAow.png)\r\n\r\n#### 原地归并\r\n\r\n先创建一个数组aux将a的元素全部赋给aux。然后开始将两个有序的数组归并成一个有序的数组。\r\n将a[lo, mid]和a[mid + 1, hi]两个有序数组归并为一个有序数组\r\n![图](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_1FWin67kuQ.png)\r\n\r\n```C/C++\r\nvoid merge(int a[], int lo, int mid, int hi)\r\n{\r\n    int i, j;\r\n    i = lo;\r\n    j = mid + 1;\r\n    int aux[hi + 1];\r\n    for (int k = lo; k <= hi; k++)\r\n    {\r\n        aux[k] = a[k];\r\n    }\r\n    for (int k = lo; k <= hi; k++)\r\n    {\r\n        if (i > mid)\r\n        {\r\n            a[k] = aux[j++];\r\n        }\r\n        else if (j > hi)\r\n        {\r\n            a[k] = aux[i++];\r\n        }\r\n        else if (aux[j] < aux[i])\r\n        {\r\n            a[k] = aux[j++];\r\n        }\r\n        else\r\n        {\r\n            a[k] = aux[i++];\r\n        }\r\n    }\r\n}\r\n```\r\n当左边（mid为中界）元素已经全部赋值到a中时，则不需要再考虑左边元素，直接把右边剩余元素全部赋值给a即可  if(i > mid)\r\n当右边（mid为中界）元素已经全部赋值到a中时，则不需要再考虑右边元素，直接把左边剩余元素全部赋值给a即可  if(j > hi)\r\n如果右边当前元素小于左边当前元素则将右边当前元素赋给a,(aux[j] < aux[i])\r\n右边当前元素大于等于左边当前元素，最后一个else\r\n\r\n#### 自上向下\r\n\r\n自顶向下归并将一个数组先中间拆分，再把拆分的数组拆分，直到只有一个元素的数组，然后将每两个数组就行归并。最后归并为一个有序数组。\r\n![图](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_pNM5lWqMZA.png)\r\n![图](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_VlHXNLFh2k.png)\r\n\r\n```C/C++\r\nvoid gbsort(int a[], int lo, int hi)\r\n{\r\n    if (hi <= lo)\r\n    {\r\n        return;\r\n    }\r\n    int mid;\r\n    mid = lo + (hi - lo) / 2;\r\n    gbsort(a, lo, mid);\r\n    gbsort(a, mid + 1, hi);\r\n    merge(a, lo, mid, hi);\r\n}\r\n```\r\n#### 自底向上\r\n\r\n自底向上归并第一次每两个元素的数组归并，然后每四个，八个......归并，最终归并成一个有序数组\r\n![图](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_3ixOLZEZqD.png)\r\n\r\n```c/c++\r\nvoid gbsort(int a[], int lo, int hi)\r\n{\r\n    int n = hi + 1; //n为数组长度\r\n    for (int i = 1; i < n; i += i)//每次循环完了归并前一次翻倍的数组元素个数\r\n    {\r\n        for (int j = 0; j < n - i; j += i * 2)\r\n        {\r\n            if (j + i * 2 - 1 < hi)\r\n            {\r\n                merge(a, j, j + i - 1, j + i * 2 - 1);\r\n            }\r\n            else {\r\n                merge(a, j, j + i - 1, hi);\r\n            }\r\n        }\r\n    }\r\n}\r\n```",
      "data": {
        "title": "归并排序",
        "date": "2020-10-23 14:57:28",
        "tags": [
          "算法",
          "排序"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/54lqq0%20(1).jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "归并排序将两个有序的排列归并为一个有序的排列。\r",
      "fileName": "gui-bing-pai-xu"
    },
    {
      "content": "### 题目描述\r\n\r\n![洛谷](https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_kZgFEYVhht.png)\r\n\r\n### 输入格式\r\n输入的每行有两个输入数据。\r\n第一个是十进制数 n。 第二个是负进制数的基数 −R。\r\n\r\n### 输出格式\r\n输出此负进制数及其基数，若此基数超过 10，则参照 16 进制的方式处理。\r\n\r\n### 输入输出样例\r\n输入 3000 -2\r\n输出 30000=11011010101110000(base-2)\r\n输入 -20000 -2\r\n输出 -20000=1111011000100000(base-2)\r\n输入 28800 -16\r\n输出 28800=19180(base-16)\r\n输入 -25000 -16\r\n输出 -25000=7FB8(base-16)\r\n\r\n### 说明\r\n【数据范围】\r\n对于 100% 的数据,−20≤R≤−2,∣n∣≤37336。\r\n\r\nNOIp2000提高组第一题\r\n\r\n\r\n### 题解：\r\n正常情况下-7 % -2 商4 余1\r\n但是C语言（或者说所有语言）这里是商3 余-1\r\n这就很明显了，只需要把商+1，被除数+1就和正常计算情况一样了\r\n\r\n\r\n\r\n#### 代码为：\r\n\r\n```C/C++\r\n#include <stdio.h>\r\n\r\nvoid zh(int a, int b)\r\n{\r\n    if (a == 0) {\r\n        return;\r\n    }\r\n    int m = a % b;\r\n    if (m < 0) {\r\n        m -= b;\r\n        a += b;\r\n    }\r\n    if (m > 9) {\r\n        m = 'A' + m - 10;\r\n    }\r\n    else\r\n        m += '0';\r\n    zh(a / b, b);\r\n    printf(\"%c\", m);\r\n}\r\n\r\nint main()\r\n{\r\n    int a, b;\r\n    scanf(\"%d%d\", &a, &b);\r\n    printf(\"%d=\", a);\r\n    zh(a, b);\r\n    printf(\"(base%d)\", b);\r\n    return 0;\r\n}\r\n```",
      "data": {
        "title": "负进制",
        "date": "2020-10-23 14:55:30",
        "tags": [
          "算法"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(8).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "fu-jin-zhi"
    },
    {
      "content": "#### 备忘录算法\r\n```C/C++\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint helper(vector<int> &m, int n);\r\nint fib(int n);\r\n\r\nint fib(int n)\r\n{\r\n    if(n < 1)\r\n    {\r\n        return 0;\r\n    }\r\n    vector<int> m(n + 1, 0);\r\n    return helper(m, n);\r\n}\r\n\r\nint helper(vector<int>&m, int n)\r\n{\r\n    if(n == 1 || n == 2) \r\n    {\r\n        return 1;\r\n    }\r\n    if (m[n] != 0)\r\n    {\r\n        return m[n];\r\n    }\r\n    m[n] = helper(m, n - 1) + helper(m, n - 2);\r\n    return m[n];\r\n} \r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    cout << fib(n);\r\n    return 0;\r\n}\r\n```\r\n#### dp数组迭代\r\n```C/C++\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint fib(int n);\r\n\r\nint fib(int n)\r\n{\r\n    if(n < 1)\r\n    {\r\n        return 0;\r\n    }\r\n    vector<int> dp(n + 1, 0);\r\n    dp[1] = dp[2] = 1;\r\n    for (int i = 3; i <= n; i++) \r\n    {\r\n        dp[i] = dp[i - 1] + dp[i - 2];\r\n    }\r\n    return dp[n];\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    cout << fib(n);\r\n    return 0;\r\n}\r\n```\r\n#### 空间优化\r\n```C/c++\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint fib(int n);\r\n\r\nint fib(int n)\r\n{\r\n    if (n == 1 || n == 2)\r\n    {\r\n        return 1;\r\n    }\r\n    int a, b, sum;\r\n    a = b = 1;\r\n    for (int i = 3; i <= n; i++) \r\n    {\r\n        sum = a + b;\r\n        a = b;\r\n        b = sum;\r\n    }\r\n    return sum;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    cin >> n;\r\n    cout << fib(n);\r\n    return 0;\r\n}\r\n```",
      "data": {
        "title": "带备忘录和dp的递归",
        "date": "2020-10-23 14:49:02",
        "tags": [
          "算法",
          "DP"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(4).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "dai-bei-wang-lu-he-dp-de-di-gui"
    },
    {
      "content": "```C/C++\r\n#include <iostream>\r\n#include <vector>\r\n#include <limits.h>\r\n#define INT_MAX 2147483647;\r\nusing namespace std;\r\n\r\nint coinchange(int coin, vector<int> &coins, int amount, vector<int> &bwl) \r\n{\r\n    if (amount < 0) return -1;\r\n    if (amount == 0) return 0;\r\n    if (bwl[amount] != 0) return bwl[amount];\r\n    int res, i, j, dp = 0, m;\r\n    m = INT_MAX;\r\n    j = 0;\r\n    res = INT_MAX;\r\n    while (j < coin) {\r\n        i = coins[j];\r\n        dp = coinchange(coin, coins, amount - i, bwl);\r\n        if (dp == -1) {\r\n            j++;\r\n            continue;\r\n        }\r\n        if (res > 1 + dp) {\r\n            res = 1 + dp;\r\n        }\r\n        j++;\r\n    }\r\n    if (res != m) {\r\n        bwl[amount] = res;\r\n    }\r\n    else {\r\n        bwl[amount] = -1;\r\n    }\r\n    return bwl[amount];\r\n}\r\n\r\nint coinChange(vector<int>& coins, int amount) \r\n{\r\n    int coin = coins.size();\r\n    vector<int> bwl(amount + 1, 0);\r\n    return coinchange(coin, coins, amount, bwl);\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    vector<int> coins;\r\n    int a, n, i = 0, amount, m;\r\n    cin >> n;\r\n    coins.clear();\r\n    while (i < n) {\r\n        cin >> a;\r\n        coins.push_back(a);\r\n        i++;\r\n    }\r\n    cin >> amount;\r\n    m = coinChange(coins, amount);\r\n    cout << m;\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n```C/C++\r\n#include <iostream>\r\n#include <limits.h>\r\n#include <vector>\r\n#define INT_MAX 2147483647;\r\nusing namespace std;\r\n\r\nint coinChange(vector<int> &coins, int amount)\r\n{\r\n    vector<int> dp(amount + 1, amount + 1);\r\n    dp[0] = 0;\r\n    int i, j;\r\n    for (i = 0; i < dp.size(); i++) \r\n    {\r\n        for (j = 0; j < coins.size(); j++)\r\n        {\r\n            if (i < coins[j])\r\n            {\r\n                continue;\r\n            }\r\n            if (dp[i] > dp[i - coins[j]]) \r\n            {\r\n                dp[i] = 1 + dp[i - coins[j]];\r\n            }\r\n        }\r\n    }\r\n    return (dp[amount] == amount + 1) ? -1 : dp[amount];\r\n}\r\n\r\nint main()\r\n{\r\n    vector<int> coins;\r\n    int a, n, i = 0, amount, m;\r\n    cin >> n;\r\n    coins.clear();\r\n    while (i < n)\r\n    {\r\n        cin >> a;\r\n        coins.push_back(a);\r\n        i++;\r\n    }\r\n    cin >> amount;\r\n    m = coinChange(coins, amount);\r\n    cout << m;\r\n    return 0;\r\n}\r\n```",
      "data": {
        "title": "凑零钱问题",
        "date": "2020-10-23 14:45:52",
        "tags": [
          "算法",
          "DP"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(7).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "cou-ling-qian-wen-ti"
    },
    {
      "content": "## C语言实现链表基本操作（交换第i个和第j个节点） \r\n\r\n### 当i或者j为1时，需要让链表的表头指向j。\r\n![开始时](https://img-blog.csdnimg.cn/20200611081240188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70)\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611081335308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020061108140129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611081415319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611081427878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70)\r\n代码为\r\n```c\r\n/*i和j为1时情况比较特殊，需要让表头重新指向交换后的那个节点*/\r\n    if (i == 1) { \r\n        t1 = *L;\r\n        for (m = 1; temp->Next != NULL; m++, temp = temp->Next) {\r\n            if (m + 1 == j) {\r\n                *L = temp->Next;\r\n                t2 = temp->Next->Next;\r\n                temp->Next->Next = t1->Next;\r\n                t1->Next = t2;\r\n                temp->Next = t1;\r\n            }\r\n        }\r\n    }\r\n```\r\n### 当i和j都不为1时。\r\n节点相邻与不相邻也是不一样的。\r\n不相邻的情况下就是让i前面的节点指向j，然后让j前面的节点指向i。如果两个节点相邻（假设i < j）j前面的节点就是i，j前面的节点指向i就是指向了自己，所以要分开写。\r\n不相邻节点时：\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611083309796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611083331554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611083418720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611083435638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70)\r\n代码为：\r\n```c\r\nif ((i - j) != 1 && (j- i) != 1) {//非相邻结点之间交换\r\n            for (m = 1; temp->Next != NULL; m++, temp = temp->Next) {\r\n                if (m + 1 == i) {\r\n                    t1 = temp;\r\n                }\r\n                if (m + 1 == j) {\r\n                    t2 = temp;\r\n                }\r\n            }\r\n            t5 = t1->Next->Next;\r\n            t3 = t1->Next;\r\n            t4 = t2->Next;\r\n            t1->Next = t4;\r\n            t2->Next = t3;\r\n            t3->Next = t4->Next;\r\n            t4->Next = t5;\r\n        }\r\n```\r\n### 最后一种情况，两个节点相邻：\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611084227643.png)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611084240634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611084255116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200611084305639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70)\r\n代码为：\r\n```c\r\nfor (m = 1; temp != NULL; m++, temp = temp->Next) {\r\n                if (m + 1 == i) {\r\n                    t1 = temp;\r\n                }\r\n                if (m == j) {\r\n                    t2 = temp;\r\n                }\r\n            }\r\n            temp = t2->Next;\r\n            t3 = t1->Next;\r\n            t1->Next = t2;\r\n            t3->Next = temp;\r\n            t2->Next = t3;\r\n        }\r\n```\r\n全部代码：\r\n```c\r\n#include <stdio.h>\r\n#include <malloc.h>\r\n\r\ntypedef struct node\r\n{\r\n    int Score;\r\n    struct node * Next;\r\n}Node, * List;\r\n\r\nvoid Insert(List *L, Node e)\r\n{\r\n    List temp = *L;\r\n    List n = (List)malloc(sizeof(Node));\r\n    n->Score = e.Score;\r\n    if (temp == NULL) {\r\n        *L = n;\r\n    }\r\n    else {\r\n        while (temp->Next != NULL) {\r\n            temp = temp->Next;\r\n        }\r\n        temp->Next = n;\r\n    }\r\n    n->Next = NULL;\r\n}\r\n\r\nvoid Swap(List * L, int i, int j)\r\n{\r\n    List temp = *L;\r\n    List t1;\r\n    List t2;\r\n    List t3;\r\n    List t4;\r\n    List t5;\r\n    int m;\r\n    /*i和j为1时情况比较特殊，需要让表头重新指向交换后的那个节点*/\r\n    if (i == 1) { \r\n        t1 = *L;\r\n        for (m = 1; temp->Next != NULL; m++, temp = temp->Next) {\r\n            if (m + 1 == j) {\r\n                *L = temp->Next;\r\n                t2 = temp->Next->Next;\r\n                temp->Next->Next = t1->Next;\r\n                t1->Next = t2;\r\n                temp->Next = t1;\r\n            }\r\n        }\r\n    }\r\n    if (j == 1) {\r\n        t1 = *L;\r\n        for (m = 1; temp->Next != NULL; m++, temp = temp->Next) {\r\n            if (m + 1 == i) {\r\n                *L = temp->Next;\r\n                t2 = temp->Next->Next;\r\n                temp->Next->Next = t1->Next;\r\n                t1->Next = t2;\r\n                temp->Next = t1;\r\n            }\r\n        }\r\n    }\r\n    /*相邻节点之间交换和非相邻结点之间交换不一样*/\r\n    else {\r\n        if ((i - j) != 1 && (j- i) != 1) {//非相邻结点之间交换\r\n            for (m = 1; temp->Next != NULL; m++, temp = temp->Next) {\r\n                if (m + 1 == i) {\r\n                    t1 = temp;\r\n                }\r\n                if (m + 1 == j) {\r\n                    t2 = temp;\r\n                }\r\n            }\r\n            t5 = t1->Next->Next;\r\n            t3 = t1->Next;\r\n            t4 = t2->Next;\r\n            t1->Next = t4;\r\n            t2->Next = t3;\r\n            t3->Next = t4->Next;\r\n            t4->Next = t5;\r\n        }\r\n        else if (i < j) {//相邻节点之间交换\r\n            for (m = 1; temp != NULL; m++, temp = temp->Next) {\r\n                if (m + 1 == i) {\r\n                    t1 = temp;\r\n                }\r\n                if (m == j) {\r\n                    t2 = temp;\r\n                }\r\n            }\r\n            temp = t2->Next;\r\n            t3 = t1->Next;\r\n            t1->Next = t2;\r\n            t3->Next = temp;\r\n            t2->Next = t3;\r\n        }\r\n        else if (i > j) {\r\n            for (m = 1; temp != NULL; m++, temp = temp->Next) {\r\n                if (m + 1 == j) {\r\n                    t1 = temp;\r\n                }\r\n                if (m == i) {\r\n                    t2 = temp;\r\n                }\r\n            }\r\n            temp = t2->Next;\r\n            t3 = t1->Next;\r\n            t1->Next = t2;\r\n            t3->Next = temp;\r\n            t2->Next = t3;\r\n        }\r\n    }\r\n}\r\n\r\nvoid printflist(List list) \r\n{\r\n    List temp;\r\n    for (temp = list; temp != NULL; temp = temp->Next) {\r\n        printf(\"%d\\n\", temp->Score);\r\n    }\r\n}\r\n\r\nvoid freelist(List *list)\r\n{\r\n    List temp = *list, del;\r\n    while (temp != NULL) {\r\n        del = temp;\r\n        temp = temp->Next;\r\n        free(del);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    List list = NULL;\r\n    Node n1, n2, n3, n4, e;//定义5个节点\r\n    e.Score = 5;\r\n    n1.Score = 1;\r\n    n2.Score = 2;\r\n    n3.Score = 3;\r\n    n4.Score = 4;\r\n    Insert(&list, n1);\r\n    Insert(&list, n2);\r\n    Insert(&list, n3);\r\n    Insert(&list, n4);\r\n    Insert(&list, e);\r\n    // dellist(&list, 8);\r\n    Swap(&list, 5, 4);\r\n    printflist(list);\r\n    freelist(&list);\r\n    return 0;\r\n}\r\n\r\n\r\n```",
      "data": {
        "title": "C语言实现链表基本操作（交换第i个和第j个节点）",
        "date": "2020-10-23 14:39:58",
        "tags": [
          "C/C++",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(3).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "c-yu-yan-shi-xian-lian-biao-ji-ben-cao-zuo-jiao-huan-di-i-ge-he-di-j-ge-jie-dian"
    },
    {
      "content": "```C/C++\r\n#include <stdio.h>\r\n#include <malloc.h>\r\n\r\ntypedef struct Node\r\n{\r\n    char data;\r\n\tstruct Node *next;\r\n}SN;\r\n\r\nSN * create(int n)\r\n{\r\n\tint i;\r\n\tSN *h,*p;\r\n    h = NULL;\r\n    for(i = 0; i<n; i++)\r\n\t{\r\n\t\tp=(SN*)malloc(sizeof(SN));\r\n\t\tprintf(\"请输入第%d个字符：\",i+1);\r\n\t\tp->data = getchar();\r\n\t\tfflush(stdin);\r\n\t\tp->next = h;\r\n\t\th=p;\r\n\t}\r\n\treturn h;\r\n}\r\n\r\nSN * def(SN * h)\r\n{ \r\n    SN * n1, *n2;\r\n\tn1 = h;\r\n\tn2 = NULL;\r\n\twhile(n1 != NULL)\r\n\t{\r\n\t\tSN *temp;\r\n\t\ttemp = n1;\r\n\t\tn1 = n1->next;\r\n\t\ttemp->next = n2;\r\n\t\tn2 = temp;\r\n\t}\r\n\th = n2;\r\n\treturn h;\r\n}\r\nvoid visit(SN * h)\r\n{ \r\n\twhile(h != NULL)\r\n\t{\r\n\t\tprintf(\"%c\", h->data);\r\n\t\th = h->next;\r\n\t}\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nvoid freelist(SN *h)\r\n{\r\n    SN *temp = h;\r\n\tSN *del;\r\n\twhile (temp != NULL) {\r\n        del = temp;\r\n        temp = temp->next;\r\n        free(del);\r\n    }\r\n}\r\n\r\nint main() \r\n{\r\n\tint n;\r\n\tSN *h;\r\n\tprintf(\"请输入字符个数：\\n\");\r\n\tscanf(\"%d\", &n);\r\n\tfflush(stdin);\r\n\th = create(n);\r\n\tprintf(\"链表创建成功，对其遍历\\n\");\r\n    visit(h);\r\n\tprintf(\"链表逆置成功，对其遍历\\n\");\r\n\th = def(h);\r\n\tvisit(h);\r\n\tfreelist(h);\r\n\treturn 0;\r\n}\r\n```",
      "data": {
        "title": "C语言链表基本操作（头插法及其逆置）",
        "date": "2020-10-23 14:32:17",
        "tags": [
          "C/C++",
          "数据结构"
        ],
        "published": true,
        "hideInList": false,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(5).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "c-yu-yan-lian-biao-ji-ben-cao-zuo-tou-cha-fa-ji-qi-ni-zhi"
    },
    {
      "content": "```python\r\nimport math\r\nimport numpy#导入两个库\r\n\r\ndef knn(c):#定义knn函数\r\n    k_a = 0\r\n    k_b = 0\r\n    distance_a = []#定义a和c的距离列表\r\n    distance_b = []#定义b和c的距离列表\r\n    distance = []#所有数据距离列表\r\n    for i in range(0, len(a)):#a的每个数据和c的每个数据的距离\r\n        distance_a.append(math.sqrt(numpy.square(a[i][0] - c[0]) + numpy.square(a[i][1] - c[1])))\r\n    for i in range(0, len(b)):#b的每个数据和c的每个数据的距离\r\n        distance_b.append(math.sqrt(numpy.square(b[i][0] - c[0]) + numpy.square(b[i][1] - c[1])))\r\n    distance = distance_a + distance_b\r\n    distance.sort()#排序距离\r\n    k = int(len(distance) / 2) + 1#取k的值\r\n    for i in range(k):\r\n        if distance_a.count(distance[i]) != 0:#判断该距离是否是a和c的距离\r\n            k_a = k_a + 1\r\n        if distance_b.count(distance[i]) != 0:#判断该距离是否是b和c的距离\r\n            k_b = k_b + 1\r\n    if k_a > k_b:#判断c的数据和哪个类别接近\r\n        print(\"你属于肥胖身材\")\r\n    else:\r\n        print(\"你属于标准身材\")\r\n\r\n\r\na = [[150, 60], [152, 65], [154, 68], [156, 70], [158, 72]]#类别a\r\nb = [[150, 49.5], [152, 50.8], [154, 52.2], [156, 53.5], [158, 54.9]]#类别b\r\nc = []  #判断类别c\r\nprint(\"输入身高体重\")\r\nfor i in range(2):#输入c\r\n    num = int(input())\r\n    c.append(num)\r\nknn(c)#调用函数knn\r\n\r\n```",
      "data": {
        "title": "机器学习-knn",
        "date": "2020-10-04 14:58:31",
        "tags": [
          "机器学习"
        ],
        "published": true,
        "hideInList": true,
        "feature": "https://cdn.jsdelivr.net/gh/Zhao-Master/cdn/img/(9).jpg.webp",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "ji-qi-xue-xi-knn"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \n\n<!-- more -->\n\n[Github](https://github.com/getgridea/gridea)  \n[Gridea 主页](https://gridea.dev/)  \n[示例网站](http://fehey.com/)\n\n## 特性👇\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \n\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \n\n🏷️  你可以对文章进行标签分组  \n\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \n\n💻  你可以在 **Windows**，**MacOS** 或 **Linux** 设备上使用此客户端  \n\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \n\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \n\n🇬🇧  你可以使用**中文简体**或**英语**  \n\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \n\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \n\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前 🏃\n\n未来，它一定会成为你离不开的伙伴\n\n尽情发挥你的才华吧！\n\n😘 Enjoy~\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/hello-gridea.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... ",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "name": "二分",
      "slug": "i3DI8ntuP",
      "used": true
    },
    {
      "name": "日常使用",
      "slug": "nzpdAnswh",
      "used": true
    },
    {
      "name": "位运算",
      "slug": "xj0bkkYnJ",
      "used": true
    },
    {
      "name": "哈希表",
      "slug": "ga7bsFqfVq",
      "used": true
    },
    {
      "name": "递归",
      "slug": "rLuxWwYz7",
      "used": true
    },
    {
      "name": "滑动窗口",
      "slug": "2-ffse4kg",
      "used": true
    },
    {
      "name": "二叉树",
      "slug": "gRTjYccGN",
      "used": true
    },
    {
      "name": "数组",
      "slug": "Q1bVstjY5",
      "used": true
    },
    {
      "name": "字符串",
      "slug": "TkFkb6Kca",
      "used": true
    },
    {
      "name": "动态规划",
      "slug": "bmv9G7VzW",
      "used": true
    },
    {
      "name": "分治",
      "slug": "e1mjcCh1kl",
      "used": true
    },
    {
      "name": "并查集",
      "slug": "gVIPoX9MAQ",
      "used": true
    },
    {
      "name": "Linux",
      "slug": "7RydGrIe5s",
      "used": true
    },
    {
      "name": "数据结构",
      "slug": "paeI_AUuZ",
      "used": true
    },
    {
      "name": "DP",
      "slug": "MdTCimxEd",
      "used": true
    },
    {
      "name": "排序",
      "slug": "k8BNlgjE1",
      "used": true
    },
    {
      "name": "双指针",
      "slug": "8QK8vw4-Q",
      "used": true
    },
    {
      "name": "搜索",
      "slug": "ssMjTlXf4",
      "used": true
    },
    {
      "name": "回溯",
      "slug": "Deq-x4lY4",
      "used": true
    },
    {
      "name": "贪心",
      "slug": "-YQxfJklo",
      "used": true
    },
    {
      "name": "LeetCode",
      "slug": "TN0UiB8Cf",
      "used": true
    },
    {
      "name": "C/C++",
      "slug": "C0PkJhDwp",
      "used": true
    },
    {
      "name": "Python",
      "slug": "PzPwXvrBB",
      "used": true
    },
    {
      "name": "机器学习",
      "slug": "a6phiPWyI",
      "used": true
    },
    {
      "name": "算法",
      "slug": "e0ZtA0F1A",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "-VkNDzNrn",
      "used": true
    },
    {
      "name": "关于",
      "slug": "5UBo7QGYK",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "https://sakuratears.cn/post/ji-lu-xue-xi-de-ri-zi",
      "name": "生活",
      "openType": "Internal"
    },
    {
      "link": "https://sakuratears.cn/post/qi-miao-de-zi-wo-miao-shu",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}